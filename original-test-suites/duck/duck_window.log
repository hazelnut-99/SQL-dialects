PRAGMA enable_verification;
PRAGMA explain_output = PHYSICAL_ONLY;
SELECT SETSEED(0.867309);
CREATE TABLE eventlog AS
	SELECT ts,
		CHR((RANDOM() * 3 + 65)::INTEGER) AS activity_name,
		(RANDOM() * 100)::INTEGER AS case_id
	FROM generate_series('2023-01-01'::TIMESTAMP, '2023-02-01'::TIMESTAMP, INTERVAL 1 HOUR) tbl(ts);
CREATE VIEW cse AS 
WITH t AS (SELECT
    string_agg(activity_name, ',' order by ts asc, activity_name) as trace,
    1 as cnt
from
    eventlog
group by case_id
)
SELECT
    trace,
    sum(cnt) as cnt_trace,
    sum(cnt_trace) over () as cnt_total,
    sum(cnt) / sum(cnt_trace) over () as rel,
    sum(cnt_trace) over (
         order by cnt_trace desc 
         ROWS between UNBOUNDED PRECEDING and CURRENT ROW) 
      / sum(cnt_trace) over () 
      as rel
from t
group by trace
order by cnt_trace desc;
EXPLAIN FROM cse;
EXPLAIN FROM cse;
EXPLAIN FROM cse;
EXPLAIN FROM cse;
CREATE VIEW noncse AS
SELECT
    quantile(x, 0.3) over() as q3,
    quantile(x, 0.7) over() as q7
FROM generate_series(1, 10) as tbl(x);
EXPLAIN FROM noncse;
PRAGMA enable_verification;
select setseed(0.618033);
CREATE TABLE flog AS
	SELECT (random() * 100)::INTEGER AS laufzeit
	, TIMESTAMP '2020-10-15 16:45:00' + INTERVAL (random() * 15 * 60) SECOND AS "timestamp"
	FROM range(26000);
select timestamp
, median(laufzeit) over w
, count(*) over w
from flog
window w as (order by timestamp asc range between interval 55 seconds preceding and interval 58 seconds following)
order by 3 desc
limit 1;
CREATE TABLE Scoreboard(TeamName VARCHAR, Player VARCHAR, Score INTEGER);
INSERT INTO Scoreboard VALUES ('Mongrels', 'Apu', 350);
INSERT INTO Scoreboard VALUES ('Mongrels', 'Ned', 666);
INSERT INTO Scoreboard VALUES ('Mongrels', 'Meg', 1030);
INSERT INTO Scoreboard VALUES ('Mongrels', 'Burns', 1270);
INSERT INTO Scoreboard VALUES ('Simpsons', 'Homer', 1);
INSERT INTO Scoreboard VALUES ('Simpsons', 'Lisa', 710);
INSERT INTO Scoreboard VALUES ('Simpsons', 'Marge', 990);
INSERT INTO Scoreboard VALUES ('Simpsons', 'Bart', 2010);
SELECT
  TeamName,
  Player,
  Score,
  NTILE(2) OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE(2) OVER (ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE(1000) OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE(1) OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE(NULL) OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE() OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE(1,2) OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE(1,2,3) OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE(1,2,3,4) OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE(-1) OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SELECT
  TeamName,
  Player,
  Score,
  NTILE(0) OVER (PARTITION BY TeamName ORDER BY Score ASC) AS NTILE
FROM ScoreBoard s
ORDER BY TeamName, Score;
SET default_null_order='nulls_first';
PRAGMA enable_verification;
CREATE TABLE list_extract_test(i INTEGER, g INTEGER);
INSERT INTO list_extract_test VALUES (1, 1), (2, 1), (3, 2), (NULL, 3), (42, 3);
CREATE VIEW list_window AS
SELECT g, LIST(i) OVER (PARTITION BY g ORDER BY i ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as l
FROM list_extract_test;
SELECT * FROM list_window ORDER BY g;
SELECT FIRST(LIST_EXTRACT(l, 1)) FROM list_window GROUP BY g ORDER BY g;
SELECT FIRST(LIST_EXTRACT(l, 2)) FROM list_window GROUP BY g ORDER BY g;
SELECT FIRST(LIST_EXTRACT(l, 3)) FROM list_window GROUP BY g ORDER BY g;
create table list_combine_test as 
	select range%3 j, 
		range::varchar AS s, 
		case when range%3=0 then '-' else '|' end sep 
	from range(1, 65);
select j, s, list(s) over (partition by j order by s) 
from list_combine_test 
order by j, s;
PRAGMA enable_verification;
CREATE TABLE tenk1 ( unique1 int4, unique2 int4, two int4, four int4, ten int4, twenty int4, hundred int4, thousand int4, twothousand int4, fivethous int4, tenthous int4, odd int4, even int4, stringu1 string, stringu2 string, string4 string );
insert into tenk1 values (4, 1621, 0, 0, 4, 4, 4, 4, 4, 4, 4, 8 ,9 ,'EAAAAA', 'JKCAAA', 'HHHHxx'), (2, 2716, 0, 2, 2, 2, 2, 2, 2, 2, 2, 4 ,5 ,'CAAAAA', 'MAEAAA', 'AAAAxx'), (1, 2838, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2 ,3 ,'BAAAAA', 'EFEAAA', 'OOOOxx'), (6, 2855, 0, 2, 6, 6, 6, 6, 6, 6, 6, 12 ,13 ,'GAAAAA', 'VFEAAA', 'VVVVxx'), (9, 4463, 1, 1, 9, 9, 9, 9, 9, 9, 9, 18 ,19 ,'JAAAAA', 'RPGAAA', 'VVVVxx'),(8, 5435, 0, 0, 8, 8, 8, 8, 8, 8, 8, 16 ,17 ,'IAAAAA', 'BBIAAA', 'VVVVxx'), (5, 5557, 1, 1, 5, 5, 5, 5, 5, 5, 5, 10 ,11,'FAAAAA', 'TFIAAA', 'HHHHxx'), (3, 5679, 1, 3, 3, 3, 3, 3, 3, 3, 3, 6 ,7 ,'DAAAAA', 'LKIAAA', 'VVVVxx'), (7, 8518, 1,3, 7, 7, 7, 7, 7, 7, 7, 14 ,15 ,'HAAAAA', 'QPMAAA', 'OOOOxx'), (0, 9998, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ,1 ,'AAAAAA','OUOAAA', 'OOOOxx');
SELECT sum(unique1) over (order by unique1 rows between 2 preceding and 2 following) su FROM tenk1 order by unique1;
SELECT sum(unique1) over (order by unique1 rows between 2 preceding and 1 preceding) su FROM tenk1 order by unique1;
SELECT sum(unique1) over (order by unique1 rows between 1 following and 3 following) su FROM tenk1 order by unique1;
SELECT sum(unique1) over (order by unique1 rows between unbounded preceding and 1 following) su FROM tenk1 order by unique1;
SELECT sum(unique1) over (order by unique1 rows between 5 following and 10 following) su FROM tenk1 order by unique1;
create table issue1472 (permno real, date date, ret real);
insert into issue1472 values
    (10000.0, '1986-02-28'::date, -0.2571428716182709),
    (10000.0, '1986-03-31'::date, 0.36538460850715637),
    (10000.0, '1986-04-30'::date, -0.09859155118465424),
    (10000.0, '1986-05-30'::date, -0.22265625),
    (10000.0, '1986-06-30'::date, -0.005025125574320555)
;
select permno,
    sum(log(ret+1)) over (PARTITION BY permno ORDER BY date rows between 12 preceding and 2 preceding),
    ret
from issue1472
ORDER BY permno, date;
create table issue1697 as
    select mod(b, 100) as a, b from (select b from range(10000) tbl(b)) t;
select avg(a) over (
    order by b asc
    rows between mod(b * 1023, 11) preceding and 23 - mod(b * 1023, 11) following)
from issue1697;
PRAGMA enable_verification;
CREATE TABLE integers(i INTEGER);
SELECT MIN(a) OVER (PARTITION BY i ORDER BY i) FROM integers;
SELECT MIN(i) OVER (PARTITION BY a ORDER BY i) FROM integers;
SELECT MIN(i) OVER (PARTITION BY i ORDER BY a) FROM integers;
SELECT MIN(i) OVER (PARTITION BY i, a ORDER BY i) FROM integers;
SELECT MIN(i) OVER (PARTITION BY i ORDER BY i, a) FROM integers;
SELECT MIN(i) OVER (PARTITION BY i ORDER BY i) FROM integers;
PRAGMA enable_verification;
CREATE TABLE t1 (id INTEGER, ch CHAR(1)) ;
INSERT INTO t1 VALUES (1, 'A');
INSERT INTO t1 VALUES (2, 'B');
INSERT INTO t1 VALUES (NULL, 'B');
SELECT id, count(*) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, count_star() OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, approx_count_distinct(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, count(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, entropy(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, any_value(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, arbitrary(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, avg(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, bit_and(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, bit_or(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, bit_xor(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, favg(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, first(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, fsum(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, group_concat(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, histogram(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, kahan_sum(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, kurtosis(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, last(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, listagg(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, mad(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, max(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, mean(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, median(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, min(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, mode(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, product(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, sem(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, skewness(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, stddev(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, stddev_pop(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, stddev_samp(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, sum(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, sum_no_overflow(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, sumkahan(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, var_pop(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, var_samp(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, variance(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, approx_quantile(id, 0.5) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, quantile(id, 0.5) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, quantile_cont(id, 0.5) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, quantile_disc(id, 0.5) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, reservoir_quantile(id, 0.5) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, arg_max(id, ch) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, arg_min(id, ch) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, argmax(id, ch) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, argmin(id, ch) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, max_by(id, ch) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, min_by(id, ch) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, array_agg(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, list(id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, bool_and(id > 0) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, bool_or(id > 0) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, corr(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, covar_pop(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, covar_samp(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, regr_avgx(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, regr_avgy(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, regr_intercept(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, regr_r2(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, regr_slope(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, regr_sxx(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, regr_sxy(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, regr_syy(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, regr_count(id, id) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
SELECT id, string_agg(id, ' ') OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
PRAGMA disable_verification;
SELECT id, bitstring_agg(id, 1, 3) OVER (PARTITION BY ch ORDER BY id ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING) 
FROM t1
ORDER BY 1;
PRAGMA threads=4;
PRAGMA verify_parallelism;
create table integers as select range i from range(0, 1000000);
select sum(s)from (
    select max(i) over(partition by i % 1024 order by i / 1024) s from integers
) q;
select sum(s)from (
    select max(i) over(partition by i % 1023 order by i / 1023) s from integers
) q;
select sum(s)from (
    select max(i) over(partition by i % 1025 order by i / 1025) s from integers
) q;
create table strings as select i, i::varchar s, (i % 1023)::varchar ms, (i / 2023)::varchar ds from integers;
select min(len(w)), max(len(w))from (
    select max(s) over(partition by ms order by ds) w from strings
) q;
select c1, lead(c1, 2) over (order by c0 rows between 2 preceding and 4 preceding) as b 
from (values 
	(1, 2), 
	(2, 3), 
	(3, 4), 
	(4, 5)
) a(c0, c1);
CREATE  TABLE "data" ("Store" INTEGER, "Dept" INTEGER, "Date" DATE, "Weekly_Sales" DOUBLE, "IsHoliday" BOOLEAN);
insert into data select * from read_csv_auto('test/sql/window/walmart.csv.gz');
PRAGMA threads=4;
SELECT "Store", "Weekly_Sales"
FROM (
	SELECT "Store", "Date", "Weekly_Sales", ROW_NUMBER() OVER (
		PARTITION BY "Store" ORDER BY "Date" DESC, "Dept"
		) r
	FROM data) w
WHERE r = 1
ORDER BY 1;
PRAGMA enable_verification;
CREATE TABLE dbplyr_052 (x INTEGER, g DOUBLE, w int);
INSERT INTO dbplyr_052 VALUES (1,1, 42),(2,1, 42),(3,1, 42),(2,2, 42),(3,2, 42),(4,2, 42);
SELECT x, g FROM (SELECT x, g, SUM(x) OVER (PARTITION BY g ORDER BY x ROWS UNBOUNDED PRECEDING) AS zzz67 FROM (SELECT x, g FROM dbplyr_052 ORDER BY x) dbplyr_053) dbplyr_054 WHERE (zzz67 > 3.0);
SELECT x, g FROM (SELECT x, g, SUM(x) OVER (PARTITION BY g ORDER BY x ROWS UNBOUNDED PRECEDING) AS zzz67 FROM (SELECT x, g FROM dbplyr_052 ORDER BY w) dbplyr_053) dbplyr_054 WHERE (zzz67 > 3.0);
SELECT x, g FROM (SELECT x, g, SUM(x) OVER (PARTITION BY g ORDER BY x ROWS UNBOUNDED PRECEDING) AS zzz67 FROM (SELECT * FROM dbplyr_052 ORDER BY x) dbplyr_053) dbplyr_054 WHERE (zzz67 > 3.0);
PRAGMA enable_verification;
create table temp as select * from range(0, 10000) temp(x);
SELECT *,
       expected=x_roll
FROM
  (SELECT x,
          rowid,
          CASE WHEN x=0 THEN 0
          ELSE x*2-1
          END AS expected,
          SUM(x) OVER (ORDER BY rowid ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS x_roll
   FROM temp) t1(x)
WHERE x BETWEEN 892 AND 902
ORDER BY x;
PRAGMA enable_verification;
CREATE TABLE mtcars (mpg DECIMAL, cyl INTEGER, disp DECIMAL, hp INTEGER, drat DECIMAL, wt DECIMAL, qsec DECIMAL, vs INTEGER, am INTEGER, gear INTEGER, carb INTEGER);
INSERT INTO mtcars VALUES ('21.0', '6', '160.0', '110', '3.90', '2.620', '16.46', '0', '1', '4', '4');
INSERT INTO mtcars VALUES ('21.0', '6', '160.0', '110', '3.90', '2.875', '17.02', '0', '1', '4', '4');
INSERT INTO mtcars VALUES ('22.8', '4', '108.0', '93', '3.85', '2.320', '18.61', '1', '1', '4', '1');
INSERT INTO mtcars VALUES ('21.4', '6', '258.0', '110', '3.08', '3.215', '19.44', '1', '0', '3', '1');
INSERT INTO mtcars VALUES ('18.7', '8', '360.0', '175', '3.15', '3.440', '17.02', '0', '0', '3', '2');
INSERT INTO mtcars VALUES ('18.1', '6', '225.0', '105', '2.76', '3.460', '20.22', '1', '0', '3', '1');
INSERT INTO mtcars VALUES ('14.3', '8', '360.0', '245', '3.21', '3.570', '15.84', '0', '0', '3', '4');
INSERT INTO mtcars VALUES ('24.4', '4', '146.7', '62', '3.69', '3.190', '20.00', '1', '0', '4', '2');
INSERT INTO mtcars VALUES ('22.8', '4', '140.8', '95', '3.92', '3.150', '22.90', '1', '0', '4', '2');
INSERT INTO mtcars VALUES ('19.2', '6', '167.6', '123', '3.92', '3.440', '18.30', '1', '0', '4', '4');
INSERT INTO mtcars VALUES ('17.8', '6', '167.6', '123', '3.92', '3.440', '18.90', '1', '0', '4', '4');
INSERT INTO mtcars VALUES ('16.4', '8', '275.8', '180', '3.07', '4.070', '17.40', '0', '0', '3', '3');
INSERT INTO mtcars VALUES ('17.3', '8', '275.8', '180', '3.07', '3.730', '17.60', '0', '0', '3', '3');
INSERT INTO mtcars VALUES ('15.2', '8', '275.8', '180', '3.07', '3.780', '18.00', '0', '0', '3', '3');
INSERT INTO mtcars VALUES ('10.4', '8', '472.0', '205', '2.93', '5.250', '17.98', '0', '0', '3', '4');
INSERT INTO mtcars VALUES ('10.4', '8', '460.0', '215', '3.00', '5.424', '17.82', '0', '0', '3', '4');
INSERT INTO mtcars VALUES ('14.7', '8', '440.0', '230', '3.23', '5.345', '17.42', '0', '0', '3', '4');
INSERT INTO mtcars VALUES ('32.4', '4', '78.7', '66', '4.08', '2.200', '19.47', '1', '1', '4', '1');
INSERT INTO mtcars VALUES ('30.4', '4', '75.7', '52', '4.93', '1.615', '18.52', '1', '1', '4', '2');
INSERT INTO mtcars VALUES ('33.9', '4', '71.1', '65', '4.22', '1.835', '19.90', '1', '1', '4', '1');
INSERT INTO mtcars VALUES ('21.5', '4', '120.1', '97', '3.70', '2.465', '20.01', '1', '0', '3', '1');
INSERT INTO mtcars VALUES ('15.5', '8', '318.0', '150', '2.76', '3.520', '16.87', '0', '0', '3', '2');
INSERT INTO mtcars VALUES ('15.2', '8', '304.0', '150', '3.15', '3.435', '17.30', '0', '0', '3', '2');
INSERT INTO mtcars VALUES ('13.3', '8', '350.0', '245', '3.73', '3.840', '15.41', '0', '0', '3', '4');
INSERT INTO mtcars VALUES ('19.2', '8', '400.0', '175', '3.08', '3.845', '17.05', '0', '0', '3', '2');
INSERT INTO mtcars VALUES ('27.3', '4', '79.0', '66', '4.08', '1.935', '18.90', '1', '1', '4', '1');
INSERT INTO mtcars VALUES ('26.0', '4', '120.3', '91', '4.43', '2.140', '16.70', '0', '1', '5', '2');
INSERT INTO mtcars VALUES ('30.4', '4', '95.1', '113', '3.77', '1.513', '16.90', '1', '1', '5', '2');
INSERT INTO mtcars VALUES ('15.8', '8', '351.0', '264', '4.22', '3.170', '14.50', '0', '1', '5', '4');
INSERT INTO mtcars VALUES ('19.7', '6', '145.0', '175', '3.62', '2.770', '15.50', '0', '1', '5', '6');
INSERT INTO mtcars VALUES ('15.0', '8', '301.0', '335', '3.54', '3.570', '14.60', '0', '1', '5', '8');
INSERT INTO mtcars VALUES ('21.4', '4', '121.0', '109', '4.11', '2.780', '18.60', '1', '1', '4', '2');
SELECT
	mpg,
	SUM(mpg) OVER (ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS mpg_roll
FROM
	mtcars;
PRAGMA enable_verification;
create table a as select case when range%2==0 then interval '1 year' else interval '2 years' end j, range::integer AS i from range(1, 5, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
PRAGMA enable_verification;
PRAGMA threads=10;
create table df as 
	select d, i v1 
	from 
		range(date '2017-01-01', date '2020-12-31', interval '1' day) t(d), 
		range(3000) i
	;
select count(*) 
from (
	select percent_rank() over (partition by d order by v1) as rank_v1 
	from df
);
PRAGMA enable_verification;
select
    *,
    array_agg(col) over(partition by id order by col collate nocase) as lead_col_nocase
from (
	select 
		unnest(array[1, 1, 1, 1]) as id, 
		unnest(array['A', 'a', 'b', 'B']) as col
);
CREATE TABLE db_city (name VARCHAR, city VARCHAR COLLATE NOCASE);
INSERT INTO db_city VALUES
	('DuckDB', 'Amsterdam'), 
	('MonetDB','amsterdam'),
	('VectorWise', 'Amstërdam');
	;
SELECT name, city, row_number() OVER (PARTITION BY city) AS row_id 
FROM db_city;
SELECT name, city, row_number() OVER (PARTITION BY city COLLATE NOCASE) AS row_id 
FROM db_city;
PRAGMA enable_verification;
select *
from (
    select lag(i, -1) over () as negative, lead(i, 1) over () as positive
    from generate_series(0, 10, 1) tbl(i)
    ) w
where negative <> positive;
CREATE TABLE empsalary (depname varchar, empno bigint, salary int, enroll_date date);
INSERT INTO empsalary VALUES ('develop', 10, 5200, '2007-08-01'), ('sales', 1, 5000, '2006-10-01'), ('personnel', 5, 3500, '2007-12-10'), ('sales', 4, 4800, '2007-08-08'), ('personnel', 2, 3900, '2006-12-23'), ('develop', 7, 4200, '2008-01-01'), ('develop', 9, 4500, '2008-01-01'), ('sales', 3, 4800, '2007-08-01'), ('develop', 8, 6000, '2006-10-01'), ('develop', 11, 5200, '2007-08-15');
SELECT depname, sum(sum(salary)) over (partition by depname order by salary) FROM empsalary group by depname, salary order by depname, salary;
SELECT empno, sum(salary*2) OVER (PARTITION BY depname ORDER BY empno) FROM empsalary ORDER BY depname, empno;
SELECT empno, 2*sum(salary) OVER (PARTITION BY depname ORDER BY empno) FROM empsalary ORDER BY depname, empno;
SELECT depname, sum(salary)*100.0000/sum(sum(salary)) OVER (PARTITION BY depname ORDER BY salary) AS revenueratio FROM empsalary GROUP BY depname, salary ORDER BY depname, revenueratio;
PRAGMA enable_verification;
create table data(id integer, value integer, primary key(id));
insert into data (id, value)
    select id, random() * 100000 as value
    from (select range as id from range(0, 1000000)) ids;
select count(*)
from (
    select value, row_number() over(order by id)
    from data
    ) w;
PRAGMA enable_verification;
BEGIN TRANSACTION;
CREATE TABLE item(i_category VARCHAR, i_brand VARCHAR, i_price INTEGER);
INSERT INTO item VALUES ('toys', 'fisher-price', 100);
SELECT i_category, i_brand, avg(sum(i_price)) OVER (PARTITION BY i_category), rank() OVER (PARTITION BY i_category ORDER BY i_category, i_brand) rn FROM item GROUP BY i_category, i_brand;
ROLLBACK;
BEGIN TRANSACTION;
CREATE TABLE item(i_category VARCHAR, i_brand VARCHAR, i_item_sk INTEGER);
CREATE TABLE store(s_store_name VARCHAR, s_company_name VARCHAR, s_store_sk INTEGER);
CREATE TABLE date_dim(d_year INTEGER, d_moy INTEGER, d_date_sk INTEGER);
CREATE TABLE store_sales(ss_sales_price DECIMAL, ss_item_sk INTEGER, ss_sold_date_sk INTEGER, ss_store_sk INTEGER);
INSERT INTO item VALUES ('Music', 'exportischolar', 1);
INSERT INTO store VALUES ('ought', 'Unknown', 1);
INSERT INTO date_dim VALUES (1999, 1, 1);
INSERT INTO store_sales VALUES (2.8, 1, 1, 1);
SELECT i_category, i_brand, s_store_name, s_company_name, d_year, d_moy, sum(ss_sales_price) sum_sales, avg(sum(ss_sales_price)) OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name, d_year) avg_monthly_sales, rank() OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name ORDER BY d_year, d_moy) rn FROM item, store_sales, date_dim, store WHERE ss_item_sk = i_item_sk AND ss_sold_date_sk = d_date_sk AND ss_store_sk = s_store_sk AND (d_year = 1999 OR (d_year = 1999-1 AND d_moy =12) OR (d_year = 1999+1 AND d_moy =1)) GROUP BY i_category, i_brand, s_store_name, s_company_name, d_year, d_moy;
ROLLBACK;
PRAGMA enable_verification;
WITH t AS (
	SELECT i, DENSE_RANK() OVER (ORDER BY i % 50) AS d
	FROM range(3000) tbl(i)
), w AS (
	SELECT d, COUNT(*) as c
	FROM t
	GROUP BY ALL
)
SELECT COUNT(*), MIN(d), MAX(d), MIN(c), MAX(c)
FROM w;
WITH t AS (
	SELECT i, DENSE_RANK() OVER (PARTITION BY i // 3000 ORDER BY i % 50) AS d
	FROM range(9000) tbl(i)
), w AS (
	SELECT d, COUNT(*) as c
	FROM t
	GROUP BY ALL
)
SELECT COUNT(*), MIN(d), MAX(d), MIN(c), MAX(c)
FROM w;
CREATE TABLE issue9416(idx VARCHAR, source VARCHAR, project VARCHAR, specimen VARCHAR, sample_id VARCHAR);
INSERT INTO issue9416 VALUES
	('197bc9528efbc76a523d796b749a69f6','json','0bf0b46fb9c01829c55e','e4de2878',NULL),
	('0f62e5fa923495012f3863e7ea05f566','json','d98171d6fe06b3','440ce2bf','9fc93ee404d6bccb69'),
	('9b15a709814582ecbec00d8397852865','json','24ed1657','c3d1f46c','06c234e260a7484'),
	('8569d67b0ccbbf316b360be3bb4fe418','json','d98171d6fe06b3','14875a37','3416100f300c7bd'),
	('d2f02b24d59696079e3d649b403fbb22','json','82e092e750a','e7deeb7f','6d8dded6f044'),
	('60a2b8898440b2f4531268e27b7d3495','json','f657d34b6','46afa8e7','7bb186ce013b'),
	('5aa1982136f3991ad5ed537793d40a0f','json','d58e2b351518','a98b2b0c','ac594941b5d9'),
	('cc70cc91af828c833b5bf20785b91918','json','4953ff4b','8450467c','d1509d0abde0'),
	('7cf99d6372183aab6a9a22205e1b0e96','json','14b5b262c52400','e7deeb7f','6d8dded6f044'),
	('3cf6f7ec6609c6456f6587c441310ace','json','0c155a1ba5','e984dd5b','d374014b756d'),
	('e1223eb2cc51161d32495ff0ad8b34ae','json','f05964c5c4','4f3354c3','10eebe991cf9'),
	('7b8b64bac7c7dc692d1fe76f6eeff2bb','json','6bd9ce7f1d8','492f260c','314d3e061be7'),
	('7b8b64bac7c7dc692d1fe76f6eeff2bb','json','249f40c5d97','492f260c','314d3e061be7'),
	('cd29186ef73b658079d848fca1ebe839','json','6bd9ce7f1d8','492f260c','314d3e061be7'),
	('d67a74eb29392e06b97161d9f3121705','json','0bf0b46fb9c01829c55e','2d28e9ee','0deb6a6b189d309'),
	('9dcc686429408e3319161c39b008f705','json','24ed1657','8450467c','d1509d0abde0'),
	('11788bb5a0477c1bfb31a9f33af80c40','json','4ea4e97b39c4b','4f3354c3','10eebe991cf9'),
	('59bceab687b4004dbeed6291f07af37d','json','6d00cb7409','4f3354c3','10eebe991cf9'),
	('76b23210847e653b6060104da0e86d5b','json','24ed1657','22f4528f','7632cf8f4849404'),
	('2605143ff05ae1ce66b1cc70f80fe53d','json','249f40c5d97','b93c50ce','be70d8b88fff'),
	('1a1864b5f4ed27acfbbf6e5069348a5a','json','6bd9ce7f1d8','6c082f61','ee109745d498'),
	('92200c3306e18e53a41550c6306a3ee4','json','8271fea91bc236c','d6f24fd5',NULL),
	('dd39e08b282cf4a6429bcfefaa2af071','json','249f40c5d97','1396d8b6','3826343264acc9'),
	('3afcae2318313f112b62536fa160678d','json','24ed1657','5311f290','129c0a0fd3e82a8'),
	('3afcae2318313f112b62536fa160678d','json','24ed1657','08b8de7c543d','129c0a0fd3e82a8'),
	('3afcae2318313f112b62536fa160678d','json','24ed1657','ce001fa3a2a4','129c0a0fd3e82a8'),
	('79acd6669071e95a5b2fe5456216ab32','json','24ed1657','5311f290','129c0a0fd3e82a8'),
	('79acd6669071e95a5b2fe5456216ab32','json','24ed1657','08b8de7c543d','129c0a0fd3e82a8'),
	('79acd6669071e95a5b2fe5456216ab32','json','24ed1657','ce001fa3a2a4','129c0a0fd3e82a8'),
	('d0a7e9d3eda115120021a895a81db8be','json','24ed1657','5311f290','129c0a0fd3e82a8'),
	('d0a7e9d3eda115120021a895a81db8be','json','24ed1657','08b8de7c543d','129c0a0fd3e82a8'),
	('d0a7e9d3eda115120021a895a81db8be','json','24ed1657','ce001fa3a2a4','129c0a0fd3e82a8'),
	('a59a3a4ad8d2ab867c9b830974588645','json','24ed1657','5311f290','129c0a0fd3e82a8'),
	('a59a3a4ad8d2ab867c9b830974588645','json','24ed1657','08b8de7c543d','129c0a0fd3e82a8'),
	('a59a3a4ad8d2ab867c9b830974588645','json','24ed1657','ce001fa3a2a4','129c0a0fd3e82a8'),
	('6193ffd18b0da96e80e2a38baac9a7e4','json','14b5b262c52400','3c03d64c34','1b5cfdd6a5de'),
	('6193ffd18b0da96e80e2a38baac9a7e4','rprt','1a5cf3833',NULL,'1b5cfdd6a5de'),
	('ecf1739fed72151784dab88dbe2f2aa9','json','14b5b262c52400','3c03d64c34','1b5cfdd6a5de'),
	('ecf1739fed72151784dab88dbe2f2aa9','rprt','1a5cf3833',NULL,'1b5cfdd6a5de'),
	('204cd9b011e2cab64bcdf1b3d668a9ef','json','7d9a79908fcc','8274fbb94a','5a928f187ed19b2'),
	('c8360bd0e28ea5bbffd66e76886bbccb','json','d6b3921920','a63d8','0e06e1f9f6580fb'),
	('c8360bd0e28ea5bbffd66e76886bbccb','rprt','d6b3921920',NULL,'0e06e1f9f6580fb'),
	('c6eb00fb5a023557439a9b898c7cc3ea','json','d6b3921920','a63d8','f891b965f2561d9'),
	('c6eb00fb5a023557439a9b898c7cc3ea','rprt','d6b3921920',NULL,'f891b965f2561d9'),
	('f2dacff642ad3f805229d7e976810f1d','rprt','d6b3921920',NULL,'6817ec9d3b7b726'),
	('8def2cd0450b56c3e0c9bb6da67b842b','rprt','d6b3921920',NULL,'6817ec9d3b7b726'),
	('6db7ef8b4a9e41bb41971dced546131b','rprt','d6b3921920',NULL,'bc32d9059dde8ba'),
	('4524efca2bf1aa0565f03a9aaf9771d2','json','14b5b262c52400','cf3b1945e2','5c0157ef5367'),
	('6f63a84401944c32b9a329af08d6473c','json','8b736466c7adc6','d0acb13cd9','d734a9d755ef6276'),
	('8ef4bc6ac39585b2ec45218ad1d06464','rprt','67b7fd541ae7e','c117f7db3b','cf94993616ef'),
	('01899ea72c60bd5e614132c99fffd48e','json','14b5b262c52400','2a50feb98b','eead79cf6ef0'),
	('b1407bdda20fad91cb9072c08c5c23a8','json','3608008ba4c9','e4840a8e75','139e04ae890beb8'),
	('2091d4939af33d3911b057ed446367f1','rprt','6522e2c00f5b87d5b','f2b8d4d02d','23de2ff19778'),
	('81f36975a777a353b0861874e03d0f95','rprt','14b5b262c52400','e05f1a1ec2','acf577df3840'),
	('5b3961bf4255e83ee1e7e795e14c8119','rprt','b9cbf09f3366297','1109e52066','47afce7dacb5'),
	('0b53312f91b22db1bf7c18251a199d36','json','14b5b262c52400','c8561fe22f','6e30638eaaf6'),
	('e277322f26cd477bae52240c46678286','json','14b5b262c52400','d185c22b68','42a062d827c'),
	('71150d87b4e7852448a524e03817efc4','json','bb87c32c765d1','3e60145162','8e072527a7cf82d'),
	('1039fc7de3c12dad1e7d3bd9e73827de','json','d6b3921920','65c0a3e2a9','9ff56f55c850390'),
	('3c67c976516f8a5a1044ad9a8935cf02','rprt','bdc5a7fd6ca','dfc9fd824b','bfbef96674e73829'),
	('56ab3e25a40913b6e961cff217a83750','json','24ed1657','724e7df1','fc81c8a39465'),
	('5f726fff8b638d0ac1ba9dcb9a4037be','json','14b5b262c52400','b1bddeb160','1e2b4afd36f'),
	('4448f84ff7496b6d1a0d311838be238d','json','14b5b262c52400','50a45c4db0','83ef23a7f827'),
	('216414a29307f00aecfc9e5cba7ac821','json','c05bced980e6381','949ae57ce4','05f77bf546f'),
	('5327f9ec2dc334bde0222b52de4d65ef','json','67b7fd541ae7e','8aea85ada0','c0048c2b539e'),
	('d3c9b836ce61a53daf39d813c97a36b9','json','249f40c5d97','35d05d68','db4853c8a41'),
	('6d4affc7041c65d0f56551f4d4370a7d','rprt','d6b3921920',NULL,'84624aa9753a681'),
	('caab5b21770a321067fb2052c2eea792','rprt','14b5b262c52400','8b8da80085','d427763bd611'),
	('eecdf1e7e87c04c56328b0d37fb06349','json','14b5b262c52400','3bfabeb9d9','7c613b2d73cc'),
	('b533aa0c674433a09cee8555b35b7ca6','json','9c3b3335f959','f9d8c52aa2','d082926c94a8a60'),
	('6dfe749835d6a895a3a116580dc4217a','rprt','14b5b262c52400','6dd9b2d650','b3d88f29e3e5'),
	('6150133032c53a35ce28c6308931137d','rprt','b04a2a75f0c4a9','9f3026e2','a1bcb7232a50'),
	('47e77fd2d027114df5ac9daa17237934','json','b04a2a75f0c4a9','6e07291b','564347d748e0'),
	('0d66c06fd2a29247b4bc798591f15cbc','rprt','093a316f6c9c0856b','ebcca53e20','4c767b833785b25b072e'),
	('997371252646aed7ac3fa43da1f69ef2','rprt','d6b3921920','5be2b052','612fc8691ec7852'),
	('e963d96d34e35ba06cea05ff78e84e41','json','33debfe262d7','114a0c85','f6d1ea3976b0a03'),
	('f50959f1079cd24b7dcb6370d8e63344','rprt','1a5cf3833',NULL,'a1b77be48d05'),
	('4e44d4c96d3d26290d13e5f9bc14d8dd','rprt','67b7fd541ae7e','c117f7db3b','18d653ec3c0'),
	('797c887ce1edab55fefaa7a690065843','rprt','14b5b262c52400','22efccc05e','7a9348e1538f'),
	('ffbc9337bb6f6c7d43ab32a9398474da','rprt','b04a2a75f0c4a9','6e07291b','564347d748e0'),
	('3ac840afe9d088e5c490ed4cd48d2269','json','67b7fd541ae7e','ffaa35275c','c58867f82d10'),
	('72cedda51ecfb6678f4e3a3956066311','json','402423768220bca1f','9a28c664','eed0f9697609'),
	('92488464899a3b31ea1bc61a2ebc2013','json','14b5b262c52400','1a10cdadd7','ee4cacc7ce10'),
	('c85e95cfec9f42fff138d498101cd7ea','json','14b5b262c52400','f1b4cf931e','3b4f71a3ddde'),
	('399edac903f69ac760fa36a8b68cdfb0','rprt','67b7fd541ae7e','a539fb31c3','4c920da298bd'),
	('a223c0e6017570f5a1039003e767e692','json','67b7fd541ae7e','7bfb6b3721','5ae5c617d126'),
	('1503860c3c6391385807ab9b6cdd1934','json','67b7fd541ae7e','4936ad40b0','94fbcb7cd167'),
	('6f269d7f6cf850a9cd0d4d804eef24a0','rprt','14b5b262c52400','943c04e54b','cc79fc503d80'),
	('732a12aa44489aeef05b614a1e8dbd2d','rprt','14b5b262c52400','a2335b4159','45e7e30aa621'),
	('b876617f4b7bdb3abc694da31b09d838','rprt','14b5b262c52400','93a91bf863','b824ed7a5f67'),
	('fd63b4bf7ee546b2c0c55200ae968872','rprt','67b7fd541ae7e','62cd05887b','9c1940a4032a'),
	('50a00a903778fb65ef92a736bd9fe262','json','67b7fd541ae7e','7e81c8b2f3','00eb98252668113'),
	('053891bc9d52d48986302c5e13adf276','json','67b7fd541ae7e','a1762f3d79','e06b767a6ed2'),
	('f537b4d753bb441436ff8d73af423691','json','efdfcef7da0','98c6db64','4c9b34c566ae'),
	('8dc4f5e5bb2663f09218b369be5bf524','rprt','03b000865c98e','f31af55c63','a02983ae108ced0449cb4'),
	('d69d899aba162c4f14593f9c6a062bdd','rprt','67b7fd541ae7e','7bfb6b3721','c32aa62b7207'),
	('88b784ce065a5cf2360e7616c4b3f7f6','json','62769691cd4e','ebdf919e','37e16f2e5319832f'),
	('cdda71f56ad05dae20b1e22ee19b227b','rprt','67b7fd541ae7e','17d7c8f29a','21c1f8fadde3'),
	('5e1d22685085f0d85553eb2b7b4155a6','rprt','14b5b262c52400','737542af23','092dcc6fdef7'),
	('7f387dad4f9bef7c2301977590cec0f2','json','67b7fd541ae7e','09591aea45','ab584388528d'),
	('a83145a960baebcf1bff9c462f8489e5','json','14b5b262c52400','2ea6e3e6fb','4fe26b0e2203'),
	('4d7a36c58267592481297676d57c9e84','json','581d813a840d3d6391','54239e1a8e','232d99055474'),
	('31f0b71e67e64d42079098a53374e094','json','14b5b262c52400','a43ad72889','7d702f310fbe'),
	('6ddc75b9771136d9a6366aaa5d951f1a','rprt','14b5b262c52400','75263a6f0c','7309f2e8695a'),
	('4595e59a1225042680842f63736481d4','json','14b5b262c52400','44f5fdb8b1','9c2c14ec6924'),
	('66c1f24117ee34a1b3d587a22047fad1','rprt','14b5b262c52400','bfe39ca56f','b49aa5fad4d5'),
	('37027bc152a681b87d5ffb9a37c325a5','rprt','efdfcef7da0','9f1668a8','682ff39acb86'),
	('c3b46edd87eb14842b6444c001ae6456','json','3608008ba4c9','f650844d13','5326d2a94e28825'),
	('82beaa8e1c8c482d792f601b37a40b8a','rprt','14b5b262c52400','c86e0093c2','5ae33221b17'),
	('333aa3a45ab3f01ad95b2a312870aa1e','json','14b5b262c52400','57f7ec0030','8545146eeba5'),
	('16b64ffcb514bf69c6936eaf4e86889e','rprt','14b5b262c52400','2a50feb98b','64bb80701037'),
	('01d42ee5515c3b500018e723278e27c1','json','67b7fd541ae7e','958967a48a','97453818ba51'),
	('2a031d3176c7d4f19c532e5d2e7b411e','rprt','14b5b262c52400','164c3bb214','3389fe2776be'),
	('8d3b5d415e43df82b6b560effeb6ee80','json','67b7fd541ae7e','9205577d7c','bc96b93082c6'),
	('339690825234f32fd7da02fd567d5109','rprt','b04a2a75f0c4a9','9f3026e2','a1bcb7232a50'),
	('13c6d4555db02b653d8f2b5ce06bb143','json','402423768220bca1f','49d58dba','59b0906f7fcb'),
	('39a39a7e3c48c1b3b262e8653b1a3ec4','rprt','14b5b262c52400','7b34590a85','eec88226d871'),
	('fdd9d71a087b9048b8ac7dd29186cedf','rprt','315316c7af745a97','8a7c0917d4','743680a0303171bbd'),
	('f37e684c9ec0d0690a3c6feeaf6b1301','json','14b5b262c52400','0059c84703','8426f8984729'),
	('3787d0c9ead3866324d7586044747d65','rprt','b9cbf09f3366297','3822b4212e','611f4b0f498e')
;
WITH dups AS (
  SELECT ROW_NUMBER() OVER same_idx AS dup
  , COUNT(*) OVER same_idx AS n_dup
  , (DENSE_RANK() OVER asc_spcmn) + (DENSE_RANK() OVER desc_spcmn) - 1 AS n_spcmn
  , *
  FROM issue9416
  WINDOW same_idx AS (
    PARTITION BY idx
    ORDER BY source, project, specimen
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
  )
  , asc_spcmn AS (
    PARTITION BY idx
    ORDER BY specimen ASC NULLS FIRST
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
  )
  , desc_spcmn AS (
    PARTITION BY idx
    ORDER BY specimen DESC NULLS LAST
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
  )
)
SELECT *
FROM dups
WHERE n_spcmn > 1
ORDER BY idx, dup;
PRAGMA enable_verification;
create table a as select range%3 j, range::varchar AS s, case when range%3=0 then '-' else '|' end sep from range(1, 7, 1);
select j, s, string_agg(s) over (partition by j order by s) from a order by j, s;
select j, s, string_agg(s, '|') over (partition by j order by s) from a order by j, s;
select j, s, string_agg(s, sep) over (partition by j order by s) from a order by j, s;
SET default_null_order='nulls_first';
PRAGMA enable_verification;
PRAGMA debug_window_mode=separate;
CREATE TABLE empsalary (depname varchar, empno bigint, salary int, enroll_date date);
INSERT INTO empsalary VALUES ('develop', 10, 5200, '2007-08-01'), ('sales', 1, 5000, '2006-10-01'), ('personnel', 5, 3500, '2007-12-10'), ('sales', 4, 4800, '2007-08-08'), ('personnel', 2, 3900, '2006-12-23'), ('develop', 7, 4200, '2008-01-01'), ('develop', 9, 4500, '2008-01-01'), ('sales', 3, 4800, '2007-08-01'), ('develop', 8, 6000, '2006-10-01'), ('develop', 11, 5200, '2007-08-15');
SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname ORDER BY empno) FROM empsalary ORDER BY depname, empno;
SELECT sum(salary) OVER (PARTITION BY depname ORDER BY salary) ss FROM empsalary ORDER BY depname, ss;
SELECT depname, min(salary) OVER (PARTITION BY depname ORDER BY salary, empno) m1, max(salary) OVER (PARTITION BY depname ORDER BY salary, empno) m2, AVG(salary) OVER (PARTITION BY depname ORDER BY salary, empno) m3 FROM empsalary ORDER BY depname, empno;
SELECT depname, STDDEV_POP(salary) OVER (PARTITION BY depname ORDER BY salary, empno) s FROM empsalary ORDER BY depname, empno;
SELECT depname, COVAR_POP(salary, empno) OVER (PARTITION BY depname ORDER BY salary, empno) c FROM empsalary ORDER BY depname, empno;
CREATE TABLE filtering AS
	SELECT
		 x
		,round(x * 0.333,0) % 3 AS y
		,round(x * 0.333,0) % 3 AS z
	FROM generate_series(0,10) tbl(x);
SELECT
	 x
	,y
	,z
	,avg(x) OVER (PARTITION BY y) AS plain_window
	,avg(x) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	,avg(x) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM filtering
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	,count(*) OVER (PARTITION BY y) AS plain_window
	,count(*) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	,count(*) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM filtering
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	,median(x) OVER (PARTITION BY y) AS plain_window
	,median(x) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	,median(x) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM filtering
ORDER BY y, x;
SELECT x, count(x) FILTER (WHERE x % 2 = 0) OVER (ORDER BY x ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING)
FROM generate_series(0,10) tbl(x);
CREATE TABLE figure1 AS 
	SELECT * 
	FROM VALUES 
			(1, 'a'),
			(2, 'b'),
			(3, 'b'),
			(4, 'c'),
			(5, 'c'),
			(6, 'b'),
			(7, 'c'),
			(8, 'a')
		v(i, s);
SELECT i
	, s
	, COUNT(DISTINCT s) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM figure1
ORDER BY i;
SELECT i
	, s
	, COUNT(DISTINCT s) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING EXCLUDE TIES) AS c
FROM figure1
ORDER BY i;
PRAGMA enable_verification;
BEGIN TRANSACTION;
create table wintest( item integer, return_ratio numeric, currency_ratio numeric);
insert into wintest values  (7539  ,0.590000 , 0.590000), (3337  ,0.626506 , 0.626506), (15597 ,0.661972 , 0.661972), (2915  ,0.698630 , 0.698630), (11933 ,0.717172 , 0.717172), (483   ,0.800000 , 0.800000), (85    ,0.857143 , 0.857143), (97    ,0.903614 , 0.903614), (117   ,0.925000 , 0.925000), (5299  ,0.927083 , 0.927083), (10055 ,0.945652 , 0.945652), (4231  ,0.977778 , 0.977778), (5647  ,0.987805 , 0.987805), (8679  ,0.988764 , 0.988764), (10323 ,0.977778 , 1.111111), (3305  ,0.737500 , 1.293860);
SELECT item, rank() OVER (ORDER BY return_ratio) AS return_rank, rank() OVER (ORDER BY currency_ratio) AS currency_rank FROM wintest order by item;
ROLLBACK;
SET default_null_order='nulls_first';
PRAGMA enable_verification;
PRAGMA verify_external;
create table modes as select range r from range(10) union all values (NULL), (NULL), (NULL);
SELECT r % 2, r, r//3, mode(r//3) over (partition by r % 2 order by r) FROM modes ORDER BY 1, 2;
SELECT r, r//3, mode(r//3) over (order by r rows between 1 preceding and 1 following) 
FROM modes 
ORDER BY ALL;
SELECT r, r//3, mode(r//3) over (order by r rows between 1 preceding and 3 following) FROM modes ORDER BY 1, 2;
SELECT r, r // 3, n, mode(n) over (partition by r % 3 order by r)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM modes) nulls
ORDER BY 1;
SELECT r, n, mode(n) over (order by r rows between 1 preceding and 1 following)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM modes) nulls
ORDER BY ALL;
SELECT r, n, mode(n) over (order by r rows between 1 preceding and 3 following)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM modes) nulls
ORDER BY 1;
SELECT r, n, mode(n) over (order by r rows between unbounded preceding and unbounded following)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM modes) nulls
ORDER BY 1;
PRAGMA debug_window_mode="window";
WITH t(r) AS (VALUES (0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (NULL), (NULL), (NULL))
SELECT r, r//3, mode(r//3) over (order by r rows between 1 preceding and 1 following) 
FROM t 
ORDER BY ALL;
PRAGMA debug_window_mode="combine";
WITH t(r) AS (VALUES (0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (NULL), (NULL), (NULL))
SELECT r, r//3, mode(r//3) over (order by r rows between 1 preceding and 1 following) 
FROM t 
ORDER BY ALL;
PRAGMA debug_window_mode="separate";
WITH t(r) AS (VALUES (0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (NULL), (NULL), (NULL))
SELECT r, r//3, mode(r//3) over (order by r rows between 1 preceding and 1 following) 
FROM t 
ORDER BY ALL;
PRAGMA enable_verification;
SELECT COUNT(DISTINCT 42) OVER ();
WITH t AS (
	SELECT col0 AS a, col1 AS b 
	FROM (VALUES
		(1,2),
		(1,1),
		(1,2),
		(2,1),
		(2,1),
		(2,2),
		(2,3),
		(2,4)
	) v) 
SELECT *, COUNT(b) OVER(PARTITION BY a), COUNT(DISTINCT b) OVER(PARTITION BY a) 
FROM t
ORDER BY 1, 2;
CREATE TABLE figure1 AS 
	SELECT * 
	FROM VALUES 
			(1, 'a'),
			(2, 'b'),
			(3, 'b'),
			(4, 'c'),
			(5, 'c'),
			(6, 'b'),
			(7, 'c'),
			(8, 'a')
		v(i, s);
SELECT i
	, s
	, COUNT(DISTINCT s) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM figure1
ORDER BY i;
WITH uncascaded AS (
	SELECT i, i % 29 AS v 
	FROM range(1000) tbl(i)
)
SELECT i
	, v
	, COUNT(DISTINCT v) OVER (ORDER BY i ROWS BETWEEN 25 PRECEDING AND 25 FOLLOWING) AS w
FROM uncascaded
ORDER BY i;
WITH cascaded AS (
	SELECT i, i % 29 AS v 
	FROM range(10000) tbl(i)
)
SELECT i
	, v
	, COUNT(DISTINCT v) OVER (ORDER BY i ROWS BETWEEN 25 PRECEDING AND 25 FOLLOWING) AS w
FROM cascaded
ORDER BY i;
SELECT i
	, s
	, i // 2 AS o
	, COUNT(DISTINCT s) OVER(
		ORDER BY i // 2
		ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING 
		EXCLUDE TIES
	) AS c
FROM figure1
ORDER BY i;
INSERT INTO figure1 VALUES 
	(9, NULL),
	(NULL, 'b'),
	(NULL, NULL),
;
SELECT i
	, s
	, COUNT(DISTINCT s) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM figure1
ORDER BY i;
CREATE TABLE nested AS
	SELECT 
		i, 
		s, 
		{"m": i % 2, "s": s} AS n,
		[(i % 2)::VARCHAR, s] AS l,
		i * i AS r
	FROM figure1;
SELECT i
	, n
	, COUNT(DISTINCT n) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM nested
ORDER BY i;
SELECT i
	, l
	, COUNT(DISTINCT l) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM nested
ORDER BY i;
SELECT r
	, s
	, COUNT(DISTINCT s) OVER( ORDER BY r RANGE BETWEEN 10 PRECEDING AND 10 FOLLOWING) AS c
FROM nested
ORDER BY i;
SELECT i
	, s
	, STRING_AGG(DISTINCT s, ', ') OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM nested
ORDER BY i;
SELECT i
	, s
	, MEDIAN(DISTINCT s) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM nested
ORDER BY i;
SELECT i
	, s
	, COUNT(DISTINCT s) FILTER (WHERE i % 3 = 0) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM nested
ORDER BY i;
SELECT i
	, s
	, COUNT(DISTINCT s) FILTER (WHERE i % 3 = 1) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM nested
ORDER BY i;
SELECT i
	, s
	, COUNT(DISTINCT s) FILTER (WHERE i % 3 = 2) OVER( ORDER BY i ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS c
FROM nested
ORDER BY i;
PRAGMA threads=4;
PRAGMA verify_parallelism;
PRAGMA enable_profiling;
PRAGMA profiling_output='duckdb_unittest_tempdir/84712/test.json';
PRAGMA profiling_mode = detailed;
create table image  (
    id          smallint primary key,
    width       int not null,
    height      integer not null
);
insert into image (id, width, height) values (1, 500, 297);
SELECT SETSEED(0.8675309);
create table pixel (
    image_id    integer not null,
    x           integer not null,
    y           integer not null,
    red         utinyint not null,
    green       utinyint not null,
    blue        utinyint not null
);
insert into pixel
    select
        1 as image_id,
        r % 500 as x,
        r // 500 as y,
        random() * 255 as red,
        random() * 255 as green,
        random() * 255 as blue
    from (select range r from range(0, 297 * 500)) r;
select count(*) from pixel;
create temp table delta1 as select range delta from range(-1,2);
create temp table delta2 as select x.delta as dx, y.delta as dy from delta1 x, delta1 y;
create sequence patchids;
create table patch AS
    SELECT p.* FROM (
        SELECT
            nextval('patchids') AS id,
            1 AS params_id,
            image_id,
            x + dx AS x_pos,
            y + dy AS y_pos,
            AVG(red) AS red_avg,
            AVG(green) AS green_avg,
            AVG(blue) AS blue_avg
        FROM pixel, delta2
        GROUP BY params_id, image_id, x_pos, y_pos
    ) p, image i
    WHERE x_pos >= 1 AND x_pos < i.width - 1
      AND y_pos >= 1 AND y_pos < i.height - 1;
select count(*) from patch;
create temp table channel (channel char(1));
insert into channel (channel) values ('R'), ('G'), ('B');
SELECT COUNT(*)
FROM (
    SELECT
        patch_id,
        channel,
        coalesce(sqrt(grad_x * grad_x + grad_y * grad_y), 0.) AS grad_mag,
        coalesce(atan2(grad_y, grad_x), 0.) AS grad_angle
    FROM (
        SELECT
            patch_id,
            channel,
            (case channel when 'R' then r_x when 'G' then g_x else b_x end) as grad_x,
            (case channel when 'R' then r_y when 'G' then g_y else b_y end) as grad_y
        FROM (
            SELECT
                patch_id,
                (r_x_1::integer - r_x_0::integer) / 2.0 as  r_x,
                (r_y_1::integer - r_y_0::integer) / 2.0 as  r_y,
                (g_x_1::integer - g_x_0::integer) / 2.0 as  g_x,
                (g_y_1::integer - g_y_0::integer) / 2.0 as  g_y,
                (b_x_1::integer - b_x_0::integer) / 2.0 as  b_x,
                (b_y_1::integer - b_y_0::integer) / 2.0 as  b_y
            FROM (
                SELECT
                    px.*,
                    lead(red,   1) OVER (w) AS r_x_1,
                    lag(red,    1) OVER (w) AS r_x_0,
                    lead(green, 1) OVER (w) AS g_x_1,
                    lag(green,  1) OVER (w) AS g_x_0,
                    lead(blue,  1) OVER (w) AS b_x_1,
                    lag(blue,   1) OVER (w) AS b_x_0,
                    lead(red,   3) OVER (w) AS r_y_1,
                    lag(red,    3) OVER (w) AS r_y_0,
                    lead(green, 3) OVER (w) AS g_y_1,
                    lag(green,  3) OVER (w) AS g_y_0,
                    lead(blue,  3) OVER (w) AS b_y_1,
                    lag(blue,   3) OVER (w) AS b_y_0
                FROM (
                    SELECT
                        p.id AS patch_id,
                        px.*
                    FROM (SELECT x + dx as x_pos, y + dy as y_pos, px.* FROM pixel px, delta2 d) px, patch p
                    WHERE px.x_pos = p.x_pos AND px.y_pos = p.y_pos
                      AND px.image_id = p.image_id
                      AND p.params_id = 1
                ) px
                WINDOW w AS (PARTITION BY patch_id ORDER BY y, x)
            ) g
            WHERE x_pos = x AND y_pos = y
        ) g, channel c
    ) g
) f;
CREATE or replace TABLE big_table AS
    SELECT
    (i % 500)::int16 AS "Pid",
    (i % 5000)::int16 AS "Planid",
    left(uuid()::VARCHAR, 10) AS "Claimid",
    FROM range(2e7::int) tbl(i);
PRAGMA temp_directory='duckdb_unittest_tempdir/84712/window_paging';
PRAGMA memory_limit='1GB';
PRAGMA verify_external;
WITH new_table as (SELECT
        Pid,
        Planid,
        Claimid,
        'CLAIM' || dense_rank() OVER(PARTITION BY Pid, Planid ORDER BY Claimid) AS Fake_Claimid
    FROM big_table
)
SELECT MAX(Fake_Claimid), COUNT(*)
FROM new_table;
PRAGMA enable_verification;
create table lineitem (
    l_extendedprice decimal(15,2),
    l_partkey integer,
    l_orderkey integer
);
insert into lineitem (values 
	(29733.00, 1, 2883),
	(1802.00, 1, 5121),
	(4505.00, 1, 6179),
	(29733.00, 1, 6273),
	(30634.00, 1, 8645),
	(41446.00, 1, 12005),
	(36040.00, 1, 16135),
	(29733.00, 1, 16198),
	(26129.00, 1, 20199),
	(24327.00, 1, 22117),
	(19822.00, 1, 24866),
	(24327.00, 1, 26756),
	(9010.00, 1, 27558),
	(45050.00, 1, 29859),
	(2703.00, 1, 34692),
	(11713.00, 1, 36611),
	(18020.00, 1, 38051),
	(21624.00, 1, 42465),
	(36040.00, 1, 42758),
	(39644.00, 1, 47620),
	(28832.00, 1, 50498),
	(12614.00, 1, 51970),
	(2703.00, 1, 53189),
	(22525.00, 1, 53825),
	(21624.00, 1, 54592),
	(36941.00, 1, 59202),
	(18942.00, 2, 548),
	(17138.00, 2, 807),
	(24354.00, 2, 2117),
	(9020.00, 2, 2528),
	(28864.00, 2, 4102),
	(42394.00, 2, 4452),
	(11726.00, 2, 7458),
	(39688.00, 2, 27969),
	(37884.00, 2, 28900),
	(9922.00, 2, 30278),
	(12628.00, 2, 30597),
	(7216.00, 2, 33058),
	(41492.00, 2, 37026),
	(40590.00, 2, 37123),
	(36982.00, 2, 39809),
	(36080.00, 2, 41415),
	(18942.00, 2, 42147),
	(24354.00, 2, 42533),
	(41492.00, 2, 43650),
	(45100.00, 2, 44103),
	(17138.00, 2, 46913),
	(31570.00, 2, 50499),
	(37884.00, 2, 54086),
	(26158.00, 2, 54436),
	(4510.00, 2, 54436),
	(3608.00, 2, 54630),
	(41492.00, 2, 55136),
);
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(), 
from lineitem 
order by l_partkey, l_orderkey;
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(order by l_partkey), 
from lineitem 
order by l_partkey, l_orderkey;
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(order by l_partkey, l_orderkey), 
from lineitem 
order by l_partkey, l_orderkey;
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(order by l_partkey, l_orderkey desc), 
from lineitem 
order by l_partkey, l_orderkey;
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(), 
	sum(l_extendedprice) over(order by l_partkey), 
	sum(l_extendedprice) over(order by l_partkey, l_orderkey), 
	sum(l_extendedprice) over(order by l_partkey, l_orderkey desc), 
from lineitem 
order by l_partkey, l_orderkey;
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(partition by l_partkey),
from lineitem 
order by l_partkey, l_orderkey;
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(partition by l_partkey order by l_orderkey),
from lineitem 
order by l_partkey, l_orderkey;
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(partition by l_partkey order by l_orderkey desc),
from lineitem 
order by l_partkey, l_orderkey, l_extendedprice desc;
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(partition by l_partkey),
	sum(l_extendedprice) over(partition by l_partkey order by l_orderkey),
	sum(l_extendedprice) over(partition by l_partkey order by l_orderkey desc),
from lineitem 
order by l_partkey, l_orderkey, l_extendedprice desc;
select 
	l_extendedprice, 
	l_partkey, 
	l_orderkey, 
	sum(l_extendedprice) over(),
	sum(l_extendedprice) over(order by l_partkey),
	sum(l_extendedprice) over(order by l_partkey, l_orderkey),
	sum(l_extendedprice) over(partition by l_partkey order by l_orderkey desc),
from lineitem 
order by l_partkey, l_orderkey, l_extendedprice desc;
CREATE  TABLE "data" ("Store" INTEGER, "Dept" INTEGER, "Date" DATE, "Weekly_Sales" DOUBLE, "IsHoliday" BOOLEAN);
insert into data select * from read_csv_auto('test/sql/window/walmart.csv.gz');
PRAGMA threads=4;
  SELECT
  *,
  lag(Weekly_Sales, 1) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_1,
  lag(Weekly_Sales, 2) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_2,
  lag(Weekly_Sales, 3) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_3,
  lag(Weekly_Sales, 4) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_4,
  lag(Weekly_Sales, 5) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_5,
  lag(Weekly_Sales, 6) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_6,
  lag(Weekly_Sales, 7) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_7,
  lag(Weekly_Sales, 8) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_8,
  lag(Weekly_Sales, 9) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_9,
  lag(Weekly_Sales, 10) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_10
FROM
  data;
  SELECT
  *,
  lag(Weekly_Sales, 1) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_1,
  lag(Weekly_Sales, 2) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_2,
  lag(Weekly_Sales, 3) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_3,
  lag(Weekly_Sales, 4) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_4,
  lag(Weekly_Sales, 5) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_5,
  lag(Weekly_Sales, 6) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_6,
  lag(Weekly_Sales, 7) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_7,
  lag(Weekly_Sales, 8) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_8,
  lag(Weekly_Sales, 9) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_9,
  lag(Weekly_Sales, 10) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_10
FROM
  data;
  SELECT
  *,
  lag(Weekly_Sales, 1) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_1,
  lag(Weekly_Sales, 2) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_2,
  lag(Weekly_Sales, 3) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_3,
  lag(Weekly_Sales, 4) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_4,
  lag(Weekly_Sales, 5) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_5,
  lag(Weekly_Sales, 6) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_6,
  lag(Weekly_Sales, 7) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_7,
  lag(Weekly_Sales, 8) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_8,
  lag(Weekly_Sales, 9) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_9,
  lag(Weekly_Sales, 10) OVER(PARTITION BY "Store", "Dept" ORDER BY "Date" ASC) AS Lag_10
FROM
  data;
PRAGMA enable_verification;
SELECT part, id, sum(val) OVER(PARTITION BY part ORDER BY id), lead(val) OVER(PARTITION BY part ORDER BY id)
FROM (SELECT range AS id, range % 5 AS part, range AS val FROM range(13)) t
ORDER BY ALL;
SELECT part, id, list_sort(list(val) OVER(PARTITION BY part))
FROM (SELECT range AS id, range % 5 AS part, range AS val FROM range(13)) t
ORDER BY ALL;
SELECT part, min(const) AS lo, max(const) AS hi
FROM (
	SELECT part, sum(val) OVER(PARTITION BY part) as const
	FROM (
		(SELECT 1 AS part, range AS val FROM range(73))
	UNION ALL
		(SELECT 2 AS part, range AS val FROM range(75))
	UNION ALL
		(SELECT 3 AS part, range AS val FROM range(77))
	UNION ALL
		(SELECT 4 AS part, range AS val FROM range(79))
	UNION ALL
		(SELECT 5 AS part, range AS val FROM range(81))
	UNION ALL
		(SELECT 6 AS part, range AS val FROM range(83))
	) u
) t
GROUP BY ALL
ORDER BY ALL
;
SELECT part, min(const) AS lo, max(const) AS hi
FROM (
	SELECT part, sum(val) OVER(PARTITION BY part) AS const
	FROM (
		SELECT part, val
		FROM (
			(SELECT range as part, random() AS val FROM range(10)) r
		CROSS JOIN 
			range(3000)
		) p
	) t
) w
GROUP BY ALL
HAVING lo <> hi
ORDER BY ALL
;
CREATE TABLE issue7353 (
    Season VARCHAR,
    Medal VARCHAR,
    Sex VARCHAR,
    Ct INT,
    Depth INT
);
INSERT INTO issue7353 (Season, Medal, Sex, Ct, Depth) VALUES
    (NULL, NULL, NULL, 271116, 0),
    ('Summer', NULL, NULL, 222552, 1),
    ('Winter', NULL, NULL, 48564, 1),
    ('Summer', 'NA', NULL, 188464, 2),
    ('Summer', 'Gold', NULL, 11459, 2),
    ('Winter', 'NA', NULL, 42869, 2),
    ('Summer', 'Bronze', NULL, 11409, 2),
    ('Winter', 'Bronze', NULL, 1886, 2),
    ('Winter', 'Gold', NULL, 1913, 2),
    ('Winter', 'Silver', NULL, 1896, 2),
    ('Summer', 'Silver', NULL, 11220, 2),
    ('Summer', 'NA', 'M', 138463, 3),
    ('Summer', 'Gold', 'M', 8319, 3),
    ('Winter', 'NA', 'F', 13268, 3),
    ('Winter', 'NA', 'M', 29601, 3),
    ('Summer', 'NA', 'F', 50001, 3),
    ('Summer', 'Bronze', 'M', 8235, 3),
    ('Winter', 'Bronze', 'M', 1289, 3),
    ('Winter', 'Gold', 'M', 1306, 3),
    ('Winter', 'Silver', 'M', 1289, 3),
    ('Summer', 'Gold', 'F', 3140, 3),
    ('Summer', 'Silver', 'M', 8092, 3),
    ('Summer', 'Bronze', 'F', 3174, 3),
    ('Summer', 'Silver', 'F', 3128, 3),
    ('Winter', 'Bronze', 'F', 597, 3),
    ('Winter', 'Gold', 'F', 607, 3),
    ('Winter', 'Silver', 'F', 607, 3);
PRAGMA default_null_order='NULLS LAST';
SELECT *, max(Ct) FILTER (WHERE Depth=1) OVER (PARTITION BY Season) as value_depth1 
from issue7353
order by all;
PRAGMA enable_verification;
CREATE TABLE issue2549 AS SELECT * FROM (VALUES
	(0, 1, 614),
	(1, 1, null),
	(2, 1, null),
	(3, 1, 639),
	(4, 1, 2027)
) tbl(id, user_id, order_id);
SELECT
  id,
  user_id,
  order_id,
  LAST_VALUE (order_id IGNORE NULLS) over (
    PARTITION BY user_id
    ORDER BY id
    ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  FIRST_VALUE (order_id IGNORE NULLS) over (
    PARTITION BY user_id
    ORDER BY id
    ROWS BETWEEN 1 PRECEDING AND UNBOUNDED FOLLOWING
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  NTH_VALUE (order_id, 2 IGNORE NULLS) over (
    PARTITION BY user_id
    ORDER BY id
    ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  LEAD(order_id, 1, -1 IGNORE NULLS) over (
    PARTITION BY user_id
    ORDER BY id
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  LAG(order_id, 1, -1 IGNORE NULLS) over (
    PARTITION BY user_id
    ORDER BY id
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  LAG(order_id, 0, -1 IGNORE NULLS) over (
    PARTITION BY user_id
    ORDER BY id
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  LAST_VALUE (order_id RESPECT NULLS) over (
    PARTITION BY user_id
    ORDER BY id
    ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  FIRST_VALUE (order_id RESPECT NULLS) over (
    PARTITION BY user_id
    ORDER BY id
    ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  NTH_VALUE (order_id, 2 RESPECT NULLS) over (
    PARTITION BY user_id
    ORDER BY id
    ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  LEAD(order_id, 1, -1 RESPECT NULLS) over (
    PARTITION BY user_id
    ORDER BY id
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  LAG(order_id, 1, -1 RESPECT NULLS) over (
    PARTITION BY user_id
    ORDER BY id
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
SELECT
  id,
  user_id,
  order_id,
  LAG(order_id, 0, -1 RESPECT NULLS) over (
    PARTITION BY user_id
    ORDER BY id
  ) AS last_order_id
FROM issue2549
ORDER BY ALL;
CREATE TABLE IF NOT EXISTS issue6635(index INTEGER, data INTEGER);
insert into issue6635 values 
	(1,1),
	(2,2),
	(3,NULL),
	(4,NULL),
	(5,5),
	(6,NULL),
	(7,NULL)
;
SELECT *, 
	first(data IGNORE NULLS) OVER w, 
	last(data IGNORE NULLS) OVER w,
	nth_value(data, 1 IGNORE NULLS) OVER w
FROM issue6635
WINDOW w AS (
	ORDER BY index 
	ROWS BETWEEN 1 FOLLOWING 
	 AND UNBOUNDED FOLLOWING
)
;
WITH gen AS (
    SELECT *,
        ((id * 1327) % 9973) / 10000.0 AS rnd
    FROM generate_series(1, 10000) tbl(id)
),
lvl AS (
    SELECT id,
        rnd,
        CASE
            WHEN rnd <= 0.1 THEN 'shallow'
            WHEN rnd >= 0.9 THEN 'high'
        END AS water_level
    FROM gen
)
SELECT *,
    LAST_VALUE(water_level IGNORE NULLS) OVER (
        ORDER BY id
    ) AS grade
FROM lvl
ORDER BY id;
SELECT ABS(x IGNORE NULLS) FROM range(10) tbl(x);
SELECT SUM(x IGNORE NULLS)
FROM range(10) tbl(x);
SELECT SUM(x IGNORE NULLS) OVER (PARTITION BY (x / 3) ORDER BY x % 3)
FROM range(10) tbl(x);
SELECT ABS(x RESPECT NULLS) FROM range(10) tbl(x);
SELECT SUM(x RESPECT NULLS)
FROM range(10) tbl(x);
SELECT SUM(x RESPECT NULLS) OVER (PARTITION BY (x / 3) ORDER BY x % 3)
FROM range(10) tbl(x);
SET default_null_order='nulls_first';
PRAGMA enable_verification;
CREATE TABLE tenk1 (unique1 int4, unique2 int4, two int4, four int4, ten int4, twenty int4, hundred int4, thousand int4, twothousand int4, fivethous int4, tenthous int4, odd int4, even int4, stringu1 varchar, stringu2 varchar, string4 varchar);
insert into tenk1 values (8800,0,0,0,0,0,0,800,800,3800,8800,0,1,'MAAAAA','AAAAAA','AAAAxx'), (1891,1,1,3,1,11,91,891,1891,1891,1891,182,183,'TUAAAA','BAAAAA','HHHHxx'), (3420,2,0,0,0,0,20,420,1420,3420,3420,40,41,'OBAAAA','CAAAAA','OOOOxx'), (9850,3,0,2,0,10,50,850,1850,4850,9850,100,101,'WOAAAA','DAAAAA','VVVVxx'), (7164,4,0,0,4,4,64,164,1164,2164,7164,128,129,'OPAAAA','EAAAAA','AAAAxx'), (8009,5,1,1,9,9,9,9,9,3009,8009,18,19,'BWAAAA','FAAAAA','HHHHxx'), (5057,6,1,1,7,17,57,57,1057,57,5057,114,115,'NMAAAA','GAAAAA','OOOOxx'), (6701,7,1,1,1,1,1,701,701,1701,6701,2,3,'TXAAAA','HAAAAA','VVVVxx'), (4321,8,1,1,1,1,21,321,321,4321,4321,42,43,'FKAAAA','IAAAAA','AAAAxx'), (3043,9,1,3,3,3,43,43,1043,3043,3043,86,87,'BNAAAA','JAAAAA','HHHHxx');
SELECT COUNT(*) OVER () FROM tenk1;
SELECT sum(four) OVER (PARTITION BY ten ORDER BY unique2) AS sum_1, ten, four FROM tenk1 WHERE unique2 < 10 order by ten, unique2;
SELECT row_number() OVER (ORDER BY unique2) rn FROM tenk1 WHERE unique2 < 10 ORDER BY rn;
SELECT rank() OVER (PARTITION BY four ORDER BY ten) AS rank_1, ten, four FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten;
SELECT dense_rank() OVER (PARTITION BY four ORDER BY ten) FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten;
SELECT first_value(ten) OVER (PARTITION BY four ORDER BY ten) FROM tenk1 WHERE unique2 < 10 order by four, ten;
SELECT cast(percent_rank() OVER (PARTITION BY four ORDER BY ten)*10 as INTEGER) FROM tenk1 ORDER BY four, ten;
SELECT cast(cume_dist() OVER (PARTITION BY four ORDER BY ten)*10 as integer) FROM tenk1 WHERE  unique2 < 10 order by four, ten;
SELECT ntile(2) OVER (ORDER BY ten, four) nn FROM tenk1 ORDER BY ten, four, nn;
SELECT ntile(3) OVER (ORDER BY ten, four) nn FROM tenk1 ORDER BY ten, four, nn;
SELECT ntile(4) OVER (ORDER BY ten, four) nn FROM tenk1 ORDER BY ten, four, nn;
SELECT ntile(5) OVER (ORDER BY ten, four) nn FROM tenk1 ORDER BY ten, four, nn;
SELECT lag(ten) OVER (PARTITION BY four ORDER BY ten) lt FROM tenk1 order by four, ten, lt;
SELECT lead(ten) OVER (PARTITION BY four ORDER BY ten) lt FROM tenk1 order by four, ten, lt;
SELECT lag(ten, four) OVER (PARTITION BY four ORDER BY ten) lt FROM tenk1 order by four, ten, lt;
SELECT lag(ten, four, 0) OVER (PARTITION BY four ORDER BY ten) lt FROM tenk1 order by four, ten, lt;
SELECT lag(ten, four, 0, 0) OVER (PARTITION BY four ORDER BY ten) lt FROM tenk1 order by four, ten, lt;
SELECT lead(ten) OVER (PARTITION BY four ORDER BY ten) lt FROM tenk1 order by four, ten, lt;
SELECT lead(ten * 2, 1) OVER (PARTITION BY four ORDER BY ten) lt FROM tenk1 order by four, ten, lt;
SELECT lead(ten * 2, 1, -1) OVER (PARTITION BY four ORDER BY ten) lt FROM tenk1 order by four, ten, lt;
SELECT COUNT(*) OVER w c, SUM(four) OVER w s, cast(AVG(ten) OVER w * 10 as integer) a, RANK() over w r, DENSE_RANK() over w dr, ROW_NUMBER() OVER w rn FROM tenk1 WINDOW w AS () ORDER BY rn;
SELECT COUNT(*) OVER w c, SUM(four) OVER w s, cast(AVG(ten) OVER w * 10 as integer) a, RANK() over w r, DENSE_RANK() over w dr, ROW_NUMBER() OVER w rn FROM tenk1 WINDOW w AS (rows between 1 preceding and 1 following) ORDER BY rn;
PRAGMA enable_verification;
CREATE TABLE empsalary (depname varchar, empno bigint, salary int, enroll_date date);
INSERT INTO empsalary VALUES ('develop', 10, 5200, '2007-08-01'), ('sales', 1, 5000, '2006-10-01'), ('personnel', 5, 3500, '2007-12-10'), ('sales', 4, 4800, '2007-08-08'), ('personnel', 2, 3900, '2006-12-23'), ('develop', 7, 4200, '2008-01-01'), ('develop', 9, 4500, '2008-01-01'), ('sales', 3, 4800, '2007-08-01'), ('develop', 8, 6000, '2006-10-01'), ('develop', 11, 5200, '2007-08-15');
SELECT depname, min(salary) OVER (PARTITION BY depname ORDER BY salary, empno) m1 FROM empsalary GROUP BY m1 ORDER BY depname, empno;
select row_number() over (range between unbounded following and unbounded preceding);
select row_number() over (range between unbounded preceding and unbounded preceding);
select LIST(salary ORDER BY enroll_date) OVER (PARTITION BY depname) FROM empsalary;
SELECT sum(i) OVER (ORDER BY i GROUPS 1 PRECEDING) FROM generate_series(1,10) AS _(i);
SELECT array_agg(i) OVER (PARTITION ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM generate_series(1,5) AS _(i)
WINDOW PARTITION AS (ORDER BY i);
SELECT array_agg(i) OVER (RANGE ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM generate_series(1,5) AS _(i)
WINDOW RANGE AS (ORDER BY i);
SELECT array_agg(i) OVER (ROWS ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM generate_series(1,5) AS _(i)
WINDOW ROWS AS (ORDER BY i);
SELECT array_agg(i) OVER (GROUPS ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM generate_series(1,5) AS _(i)
WINDOW GROUPS AS (ORDER BY i);
CREATE TABLE tbl AS SELECT 42 AS i;
SELECT SUM(i) OVER (ROWS BETWEEN UNNEST([1]) PRECEDING AND 1 FOLLOWING) FROM tbl;
SELECT SUM(i) OVER (ROWS BETWEEN 1 PRECEDING AND UNNEST([1]) FOLLOWING) FROM tbl;
SELECT lead(c0, UNNEST([1])) OVER (ROWS BETWEEN 2 PRECEDING AND 4 PRECEDING)
FROM (VALUES (1, 2)) a(c0);
SELECT x, count(x) FILTER (WHERE x % 2 = UNNEST([2])) OVER (ORDER BY x ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING)
FROM generate_series(0, 10) tbl(x);
SELECT lead(c0, 0, UNNEST([1])) OVER (ROWS BETWEEN 2 PRECEDING AND 4 PRECEDING)
FROM (VALUES (1, 2)) a(c0);
SELECT SUM(i) OVER (ROWS BETWEEN (SELECT UNNEST([1])) PRECEDING AND 1 FOLLOWING) FROM tbl;
SELECT lead(c0, (SELECT UNNEST([0])), (SELECT UNNEST([1]))) OVER (ROWS BETWEEN 2 PRECEDING AND 4 PRECEDING)
FROM (VALUES (1, 2)) a(c0);
SET default_null_order='nulls_first';
PRAGMA enable_verification;
CREATE TABLE empsalary (depname varchar, empno bigint, salary int, enroll_date date);
INSERT INTO empsalary VALUES ('develop', 10, 5200, '2007-08-01'), ('sales', 1, 5000, '2006-10-01'), ('personnel', 5, 3500, '2007-12-10'), ('sales', 4, 4800, '2007-08-08'), ('personnel', 2, 3900, '2006-12-23'), ('develop', 7, 4200, '2008-01-01'), ('develop', 9, 4500, '2008-01-01'), ('sales', 3, 4800, '2007-08-01'), ('develop', 8, 6000, '2006-10-01'), ('develop', 11, 5200, '2007-08-15');
SELECT depname, empno,
	nth_value(empno, 2) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary
ORDER BY 1, 2;
SELECT depname, empno,
	nth_value(empno, NULL) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary
ORDER BY 1, 2;
SELECT depname, empno,
	nth_value(NULL, 2) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary
ORDER BY 1, 2;
SELECT depname, empno,
	nth_value(empno, case empno % 3 when 1 then 2 else NULL end) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary
ORDER BY 1, 2;
CREATE VIEW empno_nulls AS
SELECT depname, case empno % 2 when 1 then empno else NULL end as empno, salary, enroll_date
FROM empsalary;
SELECT depname, empno,
	nth_value(empno, 2) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empno_nulls
ORDER BY 1, 2;
SELECT depname, empno, 1 + empno %3 as offset,
	nth_value(empno, 1 + empno %3) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary
ORDER BY 1, 2;
SELECT depname, empno, empno %3 as offset,
	nth_value(empno, empno %3) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary
ORDER BY 1, 2;
SELECT depname, empno,
	nth_value(-1, 2) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary
ORDER BY 1, 2;
SELECT depname, empno,
	nth_value(empno) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary;
SELECT depname, empno,
	nth_value(empno, 2, 3) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary;
PRAGMA enable_verification;
CREATE TABLE testing AS
	SELECT
		 x
		,round(x * 0.333,0) % 3 AS y
		,round(x * 0.333,0) % 3 AS z
	FROM generate_series(0,10) tbl(x);
SELECT
	 x
	,y
	,z
	,avg(x) OVER (PARTITION BY y) AS plain_window
	,avg(x) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	,avg(x) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	,count(*) OVER (PARTITION BY y) AS plain_window
	,count(*) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	,count(*) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	,median(x) OVER (PARTITION BY y) AS plain_window
	,median(x) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	,median(x) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT x, count(x) FILTER (WHERE x % 2 = 0) OVER (ORDER BY x ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING)
FROM generate_series(0,10) tbl(x);
SELECT
	 x
	,y
	,z
	, rank() OVER (PARTITION BY y) AS plain_window
	, rank() FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, rank() FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, dense_rank() OVER (PARTITION BY y) AS plain_window
	, dense_rank() FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, dense_rank() FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, row_number() OVER (PARTITION BY y) AS plain_window
	, row_number() FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, row_number() FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, percent_rank() OVER (PARTITION BY y) AS plain_window
	, percent_rank() FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, percent_rank() FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, cume_dist() OVER (PARTITION BY y) AS plain_window
	, cume_dist() FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, cume_dist() FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, ntile(x) OVER (PARTITION BY y) AS plain_window
	, ntile(x) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, ntile(x) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, first_value(x) OVER (PARTITION BY y) AS plain_window
	, first_value(x) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, first_value(x) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, last_value(x) OVER (PARTITION BY y) AS plain_window
	, last_value(x) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, last_value(x) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, lead(x) OVER (PARTITION BY y) AS plain_window
	, lead(x) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, lead(x) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, lag(x) OVER (PARTITION BY y) AS plain_window
	, lag(x) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, lag(x) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
SELECT
	 x
	,y
	,z
	, nth_value(x, 1) OVER (PARTITION BY y) AS plain_window
	, nth_value(x, 1) FILTER (WHERE x = 1) OVER (PARTITION BY y) AS x_filtered_window
	, nth_value(x, 1) FILTER (WHERE z = 0) OVER (PARTITION BY y) AS z_filtered_window
FROM testing
ORDER BY y, x;
PRAGMA enable_verification;
create table a as select range%2==0 j, range::integer AS i from range(1, 5, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%2 j, range%3==0 AS i from range(1, 5, 1);
select j, i, bool_and(i) over (), bool_or(i) over () from a order by 1,2;
select j, i, bool_and(i) over (partition by j), bool_or(i) over (partition by j) from a order by 1,2;
select j, i, bool_and(not i) over (partition by j order by i), bool_and(i) over (partition by j order by i), bool_or(i) over (partition by j order by i) from a order by 1,2;
SET default_null_order='nulls_first';
PRAGMA enable_verification;
PRAGMA verify_external;
create table quantiles as select range r from range(10) union all values (NULL), (NULL), (NULL);
SELECT r % 2, r, median(r) over (partition by r % 2 order by r) FROM quantiles ORDER BY 1, 2;
SELECT r, median(r) over (order by r rows between 1 preceding and 1 following) FROM quantiles ORDER BY 1, 2;
SELECT r, median(r) over (order by r rows between 1 preceding and 3 following) FROM quantiles ORDER BY 1, 2;
SELECT r, quantile(r, 0.5) over (order by r rows between 1 preceding and 3 following) FROM quantiles ORDER BY 1, 2;
SELECT r % 2, r, median(r::VARCHAR) over (partition by r % 2 order by r) FROM quantiles ORDER BY 1, 2;
SELECT r, median(r::VARCHAR) over (order by r rows between 1 preceding and 1 following) FROM quantiles ORDER BY 1, 2;
SELECT r, quantile(r::VARCHAR, 0.5) over (order by r rows between 1 preceding and 3 following) FROM quantiles ORDER BY 1, 2;
SELECT r, median('prefix-' || r::VARCHAR || '-suffix') over (order by r rows between 1 preceding and 1 following) FROM quantiles ORDER BY 1, 2;
SELECT r % 3, r, n, median(n) over (partition by r % 3 order by r)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM quantiles) nulls
ORDER BY 1, 2;
SELECT r, n, median(n) over (order by r rows between 1 preceding and 1 following)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM quantiles) nulls
ORDER BY 1;
SELECT r, n, median(n) over (order by r rows between 1 preceding and 3 following)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM quantiles) nulls
ORDER BY 1;
SELECT r, n, median(n) over (order by r rows between unbounded preceding and unbounded following)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM quantiles) nulls
ORDER BY 1;
WITH t(i, p, f) AS (VALUES
	(0, 1, 1),
	(1, 1, 1),
	(2, 1, 1),
	(3, 3, 1),
	(4, 1, 1),
	(5, 3, 1)
)
SELECT i, MEDIAN(i) OVER (ORDER BY i ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 1),
	(1, 1, 1, 1),
	(2, 2, 1, 1),
	(3, 0, 1, 1),
	(4, 1, 1, 1),
	(5, 2, 1, 1)
)
SELECT r, MEDIAN(i) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 3, 1, 2),
	(4, 4, 1, 2),
	(5, 5, 1, 2)
)
SELECT r, QUANTILE_DISC(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, NULL, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 3, 1, 2),
	(4, 4, 1, 2),
	(5, 5, 1, 2)
)
SELECT r, QUANTILE_DISC(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, NULL, 1, 2),
	(1, NULL, 1, 2),
	(2, NULL, 1, 2),
	(3, NULL, 1, 2),
	(4, NULL, 1, 2),
	(5, NULL, 1, 2)
)
SELECT r, QUANTILE_DISC(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 3, 1, 2),
	(4, 4, 1, 2),
	(5, 5, 1, 2)
)
SELECT r, QUANTILE_CONT(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 0, 1, 2),
	(4, 1, 1, 2),
	(5, 2, 1, 2)
)
SELECT r, QUANTILE_CONT(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
SELECT r, quantile_disc(i, 0.5) OVER (ORDER BY r ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) q
FROM (VALUES
	(0, 0),
	(1, 1),
	(2, 2),
	(3, 0),
	(4, 1)
	) tbl(r, i)
ORDER BY 1, 2;
SELECT r, quantile_cont(i, 0.5) OVER (ORDER BY r ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING) q
FROM (VALUES
	(0, 0),
	(1, 1),
	(2, 2),
	(3, 3),
	(4, 0),
	(5, 1)
	) tbl(r, i)
ORDER BY 1, 2;
SELECT r, quantile_cont(i, 0.5) OVER (ORDER BY r ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING) q
FROM (VALUES
	(0, NULL),
	(1, 1),
	(2, 2),
	(3, 3),
	(4, NULL),
	(5, 1)
	) tbl(r, i)
ORDER BY 1, 2;
PRAGMA debug_window_mode="window";
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 1),
	(1, 1, 1, 1),
	(2, 2, 1, 1),
	(3, 0, 1, 1),
	(4, 1, 1, 1),
	(5, 2, 1, 1)
)
SELECT r, MEDIAN(i) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 1),
	(1, 1, 1, 1),
	(2, 2, 1, 1),
	(3, 0, 1, 1),
	(4, 1, 1, 1),
	(5, 2, 1, 1)
)
SELECT r, QUANTILE_DISC(i, 0.5) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, NULL, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 3, 1, 2),
	(4, 4, 1, 2),
	(5, 5, 1, 2)
)
SELECT r, QUANTILE_DISC(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 0, 1, 2),
	(4, 1, 1, 2),
	(5, 2, 1, 2)
)
SELECT r, QUANTILE_CONT(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
PRAGMA debug_window_mode="combine";
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 1),
	(1, 1, 1, 1),
	(2, 2, 1, 1),
	(3, 0, 1, 1),
	(4, 1, 1, 1),
	(5, 2, 1, 1)
)
SELECT r, MEDIAN(i) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 1),
	(1, 1, 1, 1),
	(2, 2, 1, 1),
	(3, 0, 1, 1),
	(4, 1, 1, 1),
	(5, 2, 1, 1)
)
SELECT r, QUANTILE_DISC(i, 0.5) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, NULL, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 3, 1, 2),
	(4, 4, 1, 2),
	(5, 5, 1, 2)
)
SELECT r, QUANTILE_DISC(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 0, 1, 2),
	(4, 1, 1, 2),
	(5, 2, 1, 2)
)
SELECT r, QUANTILE_CONT(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
PRAGMA debug_window_mode="separate";
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 1),
	(1, 1, 1, 1),
	(2, 2, 1, 1),
	(3, 0, 1, 1),
	(4, 1, 1, 1),
	(5, 2, 1, 1)
)
SELECT r, MEDIAN(i) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 1),
	(1, 1, 1, 1),
	(2, 2, 1, 1),
	(3, 0, 1, 1),
	(4, 1, 1, 1),
	(5, 2, 1, 1)
)
SELECT r, QUANTILE_DISC(i, 0.5) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, NULL, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 3, 1, 2),
	(4, 4, 1, 2),
	(5, 5, 1, 2)
)
SELECT r, QUANTILE_DISC(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
WITH t(r, i, p, f) AS (VALUES
	(0, 0, 1, 2),
	(1, 1, 1, 2),
	(2, 2, 1, 2),
	(3, 0, 1, 2),
	(4, 1, 1, 2),
	(5, 2, 1, 2)
)
SELECT r, QUANTILE_CONT(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PRECEDING and f FOLLOWING)
FROM t
ORDER BY 1;
PRAGMA enable_verification;
create table integers as select range i from range(0,16);
select max(base), max(referenced), sum(refined), sum(unrefined) from (
    select
    	row_number() over w AS base,
    	row_number() over (w) as referenced,
    	sum(i % 4) over (w rows between 1 preceding and 1 following) AS refined,
    	sum(i % 4) over (rows between 1 preceding and 1 following) AS unrefined
    from integers
    WINDOW w AS (partition by i // 4 order by i % 4)
) q;
select 
  x, y, 
  count(*) over (partition by y order by x), 
  count(*) over (w order by x)
from (values (1, 1), (2, 1), (3, 2), (4, 2)) as t (x, y)
window w as (partition by y)
order by x;
select 
  x, y, 
  count(*) over (partition by y order by x), 
  count(*) over (w order by x)
from (values (1, 1), (2, 1), (3, 2), (4, 2)) as t (x, y)
window w as (partition by y order by x desc)
order by x;
select 
  x, y, 
  count(*) over (partition by y order by x), 
  count(*) over (w partition by y)
from (values (1, 1), (2, 1), (3, 2), (4, 2)) as t (x, y)
window w as (partition by x)
order by x;
select i, sum(i) over (w) as smoothed 
from integers 
window w AS (order by i rows between 1 preceding and 1 following) 
order by i;
SELECT sum(1) over cumulativeSum 
FROM integers 
WINDOW cumulativeSum AS (), 
	cumulativesum AS (order by i rows between 1 preceding and 1 following);
SELECT sum(i) over cumulativeSum 
FROM integers 
WINDOW cumulativeSum AS ();
SET default_null_order='nulls_first';
PRAGMA enable_verification;
create table mads as select range r from range(20) union all values (NULL), (NULL), (NULL);
SELECT r % 2 as p, r, r/3.0, mad(r/3.0) over (partition by r % 2 order by r)
FROM mads ORDER BY 1, 2;
SELECT r, r/3.0, mad(r/3.0) over (order by r rows between 1 preceding and 1 following)
FROM mads ORDER BY 1, 2;
SELECT r, r/3.0, mad(r/3.0) over (order by r rows between 1 preceding and 3 following) FROM mads ORDER BY 1, 2;
SELECT r % 3 as p, r, n, mad(n) over (partition by r % 3 order by r)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM mads) nulls
ORDER BY 1, 2;
SELECT r, n, mad(n) over (order by r rows between 1 preceding and 1 following)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM mads) nulls
ORDER BY 1;
SELECT r, n, mad(n) over (order by r rows between 1 preceding and 3 following)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM mads) nulls
ORDER BY 1;
SELECT r, n, mad(n) over (order by r rows between unbounded preceding and unbounded following)
FROM (SELECT r, CASE r % 2 WHEN 0 THEN r ELSE NULL END AS n FROM mads) nulls
ORDER BY 1;
CREATE TABLE coverage AS SELECT * FROM (VALUES
	(1), (2), (3), (1)
	) tbl(r);
SELECT r, mad(r) OVER (ORDER BY r ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
FROM coverage
ORDER BY 1;
PRAGMA debug_window_mode="window";
SELECT r % 2 as p, r, r/3.0, mad(r/3.0) over (partition by r % 2 order by r)
FROM mads ORDER BY 1, 2;
PRAGMA debug_window_mode="combine";
SELECT r % 2 as p, r, r/3.0, mad(r/3.0) over (partition by r % 2 order by r)
FROM mads ORDER BY 1, 2;
PRAGMA debug_window_mode="separate";
SELECT r % 2 as p, r, r/3.0, mad(r/3.0) over (partition by r % 2 order by r)
FROM mads ORDER BY 1, 2;
PRAGMA enable_verification;
create table tenk1d(ten int4, four int4);
insert into tenk1d values (0,0), (1,1), (3,3), (2,2), (4,2), (9,1), (4,0), (7,3), (0,2), (2,0), (5,1), (1,3), (3,1), (6,0), (8,0), (9,3), (8,2), (6,2), (7,1), (5,3);
SELECT four, ten, sum(ten) over (partition by four order by ten) st, last_value(ten) over (partition by four order by ten) lt FROM tenk1d ORDER BY four, ten;
SELECT four, ten, sum(ten) over (partition by four order by ten range between unbounded preceding and current row) st, last_value(ten) over (partition by four order by ten range between unbounded preceding and current row) lt FROM tenk1d order by four, ten;
SELECT four, ten, sum(ten) over (partition by four order by ten range between unbounded preceding and unbounded following) st, last_value(ten) over (partition by four order by ten range between unbounded preceding and unbounded following) lt FROM tenk1d order by four, ten;
SELECT four, ten//4 as two, 	sum(ten//4) over (partition by four order by ten//4 range between unbounded preceding and current row) st, last_value(ten//4) over (partition by four order by ten//4 range between unbounded preceding and current row) lt FROM tenk1d order by four, ten//4;
SELECT four, ten//4 as two, sum(ten//4) OVER w st, last_value(ten//4) OVER w lt FROM tenk1d WINDOW w AS (partition by four order by ten//4 range between unbounded preceding and current row) order by four, ten//4;
PRAGMA enable_verification;
CREATE TABLE tenk1d (
        unique1	        int4,
		four		int4,
        col             int4
);
INSERT INTO tenk1d (unique1, four, col) VALUES 
  (0, 0, NULL),
  (1, 1, 1),
  (2, 2, NULL),
  (3, 3, 3),
  (4, 0, NULL),
  (5, 1, 1),
  (6, 2, NULL),
  (7, 3, 3),
  (8, 0, NULL),
  (9, 1, 1);
CREATE TABLE empsalary (
depname varchar,
empno bigint,
salary int,
enroll_date date
);
INSERT INTO empsalary VALUES
('develop', 10, 5200, '2007-08-01'),
('sales', 1, 5000, '2006-10-01'),
('personnel', 5, 3500, '2007-12-10'),
('sales', 4, 4800, '2007-08-08'),
('personnel', 2, 3900, '2006-12-23'),
('develop', 7, 4200, '2008-01-01'),
('develop', 9, 4500, '2008-01-01'),
('sales', 3, 4800, '2007-08-01'),
('develop', 8, 6000, '2006-10-01'),
('develop', 11, 5200, '2007-08-15');
SELECT sum(unique1) over (w range between unbounded preceding and current row exclude current row),
	unique1, four
FROM tenk1d  WINDOW w AS (order by four) ORDER BY four, unique1;
SELECT sum(unique1) over (w range between unbounded preceding and current row exclude group),
	unique1, four
FROM tenk1d  WINDOW w AS (order by four) ORDER BY four, unique1;
SELECT sum(unique1) over (w range between unbounded preceding and current row exclude ties),
	unique1, four
FROM tenk1d  WINDOW w AS (order by four) ORDER BY four, unique1;
SELECT sum(unique1) over (partition by four order by unique1 range between 5::int8 preceding and 6::int2 following
	exclude current row),unique1, four
FROM tenk1d  ORDER BY four, unique1;
SELECT sum(unique1) filter (where four > 1)over (order by unique1 rows between unbounded preceding and current row
	exclude current row),unique1, four
FROM tenk1d  ORDER BY unique1, four;
SELECT sum(unique1) filter (where four > 0) over (partition by four order by unique1 rows between unbounded preceding
        and current row exclude current row),unique1, four
FROM tenk1d  ORDER BY unique1, four;
SELECT first_value(four) over (order by four rows between unbounded preceding
        and current row exclude group), four
FROM tenk1d ORDER BY four;
SELECT last_value(four) over (order by four rows between current row
        and unbounded following exclude current row), four
FROM tenk1d ORDER BY four;
SELECT nth_value(four, 5) over (order by four rows between unbounded preceding
        and unbounded following exclude ties), four
FROM tenk1d ORDER BY four;
SELECT nth_value(col, 3 ignore nulls) over (order by four rows between unbounded preceding                                               
       and unbounded following exclude current row),four, col
FROM tenk1d ORDER BY four, col;
SELECT DISTINCT first_value(col IGNORE NULLS) OVER (ORDER BY i ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE CURRENT ROW)
FROM (  SELECT * 
        FROM generate_series(1,3000) AS _(i), (SELECT NULL::integer)
          UNION ALL
        SELECT 3001, 1
     ) AS _(i, col)
ORDER BY ALL NULLS FIRST;
SELECT sum(unique1) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE CURRENT ROW), unique1
FROM tenk1d ORDER BY unique1;
SELECT sum(unique1) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE GROUP), unique1
FROM tenk1d ORDER BY unique1;
SELECT sum(unique1) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE TIES), unique1
FROM tenk1d ORDER BY unique1;
SELECT DISTINCT j,sum(j) OVER (ORDER BY j ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE GROUP) FROM generate_series(1,300), generate_series(1,10) AS __(j) ORDER BY j;
SELECT i, last_value(i) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE CURRENT ROW) FROM generate_series(1,10) AS _(i)
WHERE i <> 10
ORDER BY i;
SELECT DISTINCT j,sum(j) OVER (ORDER BY j ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE TIES) FROM generate_series(1,300), generate_series(1,10) AS __(j) ORDER BY j;
SELECT DISTINCT j,sum(j) FILTER (where i <> 3) OVER (ORDER BY j ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE TIES) AS sum FROM generate_series(1,300) _(i), generate_series(1,10) AS __(j) ORDER BY j, sum;
SELECT j, sum(j) OVER (ORDER BY j ROWS BETWEEN UNBOUNDED PRECEDING AND 30 FOLLOWING EXCLUDE CURRENT ROW) FROM generate_series(1,40) AS _(j) ORDER BY j;
EXPLAIN
SELECT unique1, COUNT(*) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE CURRENT ROW) FROM tenk1d;
SELECT unique1, four, sum(unique1) OVER (PARTITION BY four ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE CURRENT ROW) FROM tenk1d ORDER BY four, unique1;
SELECT unique1, four, sum(unique1) OVER (PARTITION BY four ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE GROUP) FROM tenk1d ORDER BY four, unique1;
SELECT unique1, four, sum(unique1) OVER (PARTITION BY four ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE TIES) FROM tenk1d ORDER BY four, unique1;
SELECT i, COUNT(*) OVER (ORDER BY i ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING EXCLUDE CURRENT ROW) 
FROM generate_series(1,10) AS _(i) 
ORDER BY i;
SELECT i, COUNT(*) OVER (ORDER BY i ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING EXCLUDE GROUP) 
FROM (
	SELECT * FROM generate_series(1,5) 
	UNION ALL 
	SELECT * FROM generate_series(1,5)
) AS _(i) 
ORDER BY i;
SELECT i, COUNT(*) OVER (ORDER BY i ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING EXCLUDE TIES) 
FROM (
	SELECT *  FROM generate_series(1,5) 
	UNION ALL 
	SELECT *  FROM generate_series(1,5)) 
	AS _(i) 
ORDER BY i;
SELECT i, array_agg(i) OVER w
FROM (
	SELECT * FROM generate_series(1,5)
    UNION ALL
    SELECT * FROM generate_series(1,5) 
) AS _(i)
WINDOW w AS (ORDER BY i ROWS UNBOUNDED PRECEDING EXCLUDE CURRENT ROW)
ORDER BY i;
SELECT i, array_agg(i) OVER w
FROM (
	SELECT * FROM generate_series(1,5)
    UNION ALL
    SELECT * FROM generate_series(1,5) 
) AS _(i)
WINDOW w AS (ORDER BY i ROWS UNBOUNDED PRECEDING EXCLUDE GROUP)
ORDER BY i;
SELECT i, array_agg(i) OVER w
FROM (
	SELECT * FROM generate_series(1,5)
    UNION ALL
    SELECT * FROM generate_series(1,5) 
) AS _(i)
WINDOW w AS (ORDER BY i ROWS UNBOUNDED PRECEDING EXCLUDE TIES)
ORDER BY i;
SELECT i, mode(i) OVER  w
FROM (
	SELECT * FROM generate_series(1,5)
    UNION ALL
    SELECT * FROM generate_series(1,5) 
) AS _(i)
WINDOW w AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE CURRENT ROW)
ORDER BY i;
SELECT i, mode(i) OVER  w
FROM (
	SELECT * FROM generate_series(1,5)
    UNION ALL
    SELECT * FROM generate_series(1,5) 
) AS _(i)
WINDOW w AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE GROUP)
ORDER BY i;
SELECT i, mode(i) OVER w 
FROM (
	SELECT * FROM generate_series(1,5)
    UNION ALL
    SELECT * FROM generate_series(1,5) 
) AS _(i)
WINDOW w AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE TIES)
ORDER BY i;
SELECT i, median(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE CURRENT ROW) 
FROM generate_series(1,10) AS _(i) ORDER BY i;
SELECT i, median(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE GROUP) 
FROM generate_series(1,5) AS _(i), 
	generate_series(1,2) 
ORDER BY i;
SELECT i, median(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE TIES) 
FROM generate_series(1,5) AS _(i), 
	generate_series(1,2) 
ORDER BY i;
WITH t1(x, y) AS (VALUES
 ( 1, 3 ),
 ( 2, 2 ),
 ( 3, 1 )
)
SELECT x, y, QUANTILE_DISC(y, 0) OVER (
	ORDER BY x 
	ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
	EXCLUDE CURRENT ROW)
FROM t1;
WITH t1(x, y) AS (VALUES
 ( 1, 3 ),
 ( 2, 2 ),
 ( 3, 1 )
)
SELECT x, y, QUANTILE_DISC(y, 0) OVER (
	ORDER BY x 
	ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
	EXCLUDE CURRENT ROW)
FROM t1;
select sum(salary) over (order by enroll_date range between '1 year'::interval preceding and '1 year'::interval following
	exclude current row), salary, enroll_date from empsalary ORDER BY enroll_date, salary;
select sum(salary) over (order by enroll_date range between '1 year'::interval preceding and '1 year'::interval following
	exclude group), salary, enroll_date from empsalary ORDER BY enroll_date, salary;
select sum(salary) over (order by enroll_date range between '1 year'::interval preceding and '1 year'::interval following
	exclude ties), salary, enroll_date from empsalary ORDER BY enroll_date, salary;
select first_value(salary) over(order by salary range between 1000 preceding and 1000 following) AS first_value,
	lead(salary) over(order by salary range between 1000 preceding and 1000 following) AS lead,
	nth_value(salary, 1) over(order by salary range between 1000 preceding and 1000 following),
	salary from empsalary ORDER BY first_value, lead;
select last_value(salary) over(order by salary range between 1000 preceding and 1000 following) AS last_value,
	lag(salary) over(order by salary range between 1000 preceding and 1000 following) AS lag,
	salary from empsalary ORDER BY last_value, lag;
select first_value(salary) over(order by salary range between 1000 following and 3000 following
	exclude current row) AS first_value,
	lead(salary) over(order by salary range between 1000 following and 3000 following exclude ties) AS lead,
	nth_value(salary, 1) over(order by salary range between 1000 following and 3000 following
	exclude ties),
	salary from empsalary ORDER BY first_value, lead;
select last_value(salary) over(order by salary range between 1000 following and 3000 following
	exclude group) AS last_value,
	lag(salary) over(order by salary range between 1000 following and 3000 following exclude group) AS lag,
	salary from empsalary ORDER BY last_value, lag;
SELECT sum(i) OVER (EXCLUDE CURRENT ROW) FROM generate_series(1,10) AS _(i);
SELECT sum(i) OVER (ROWS UNBOUNDED PRECEDING EXCLUDE GROUPS) FROM generate_series(1,10) AS _(i);
PRAGMA enable_verification;
PRAGMA explain_output = PHYSICAL_ONLY;
create table integers (i int, j int);
insert into integers values (2, 2), (2, 1), (1, 2), (1, NULL);
explain select first_value(i IGNORE NULLS) over () from integers;
EXPLAIN
SELECT i, COUNT(*) OVER() FROM integers;
EXPLAIN
SELECT i, SUM(i) OVER() FROM integers;
EXPLAIN
SELECT j, COUNT(j) FILTER(WHERE i = 2) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM integers;
EXPLAIN
SELECT j, SUM(j) FILTER(WHERE i = 2) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM integers;
explain select row_number() over (), i, j from integers;
select row_number() over (), i, j from integers;
explain select rank() over (), i, j from integers;
select rank() over (), i, j from integers;
explain select dense_rank() over (), i, j from integers;
select dense_rank() over (), i, j from integers;
explain select percent_rank() over (), i, j from integers;
select percent_rank() over (), i, j from integers;
EXPLAIN
SELECT i, COUNT(*) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM integers;
SELECT i, COUNT(*) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM integers;
EXPLAIN
SELECT j, COUNT(j) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM integers;
SELECT j, COUNT(j) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM integers;
EXPLAIN
SELECT i, SUM(i) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM integers;
EXPLAIN
SELECT i, SUM(i) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM integers;
SELECT i, SUM(i) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM integers;
EXPLAIN
SELECT SUM(s) FROM (
	SELECT SUM(i) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) s
	FROM range(5000) tbl(i)
);
SELECT SUM(s) FROM (
	SELECT SUM(i) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) s
	FROM range(5000) tbl(i)
);
explain select i, j, first_value(i) over (), first_value(j) over () from integers;
select i, j, first_value(i) over (), first_value(j) over () from integers;
select row_number() over (), first_value(i) over (), first_value(j) over () from integers;
select row_number() over (), row_number() over () from integers;
explain select first_value(i IGNORE NULLS) over () from integers;
explain select first_value(i) over (), last_value(i) over () from integers;
explain select last_value(i) over (), first_value(i) over () from integers;
explain select first_value(i) over (), last_value(i) over (order by j) from integers;
explain select last_value(i) over (order by j), first_value(i) over () from integers;
CREATE TABLE v1(id bigint);
CREATE TABLE v2(id bigint);
INSERT INTO v1 VALUES (11),  (12),  (13);
INSERT INTO v2 VALUES (21),  (22);
CREATE VIEW vertices_view AS
  SELECT * FROM v1
  UNION ALL
  SELECT * FROM v2;
SELECT id AS sparse_id, row_number() OVER () AS rnum
FROM vertices_view;
WITH RECURSIVE rte AS (
	SELECT 1 l, 1::BIGINT r
	UNION  ALL
	SELECT l+1, row_number() OVER()
	FROM rte
	WHERE l < 3
)
SELECT * FROM rte;
PREPARE sw1 AS
	SELECT i, row_number() OVER() AS row_no
	FROM range(10, 20) tbl(i)
	QUALIFY row_no <= ?::BIGINT
;
EXECUTE sw1(10);
EXECUTE sw1(2);
PRAGMA enable_verification;
WITH t AS (
	SELECT i, RANK() OVER (ORDER BY i % 50) AS d
	FROM range(3000) tbl(i)
), w AS (
	SELECT d, COUNT(*) as c
	FROM t
	GROUP BY ALL
)
SELECT COUNT(*), MIN(d), MAX(d), MIN(c), MAX(c)
FROM w;
WITH t AS (
	SELECT i, RANK() OVER (PARTITION BY i // 3000 ORDER BY i % 50) AS d
	FROM range(9000) tbl(i)
), w AS (
	SELECT d, COUNT(*) as c
	FROM t
	GROUP BY ALL
)
SELECT COUNT(*), MIN(d), MAX(d), MIN(c), MAX(c)
FROM w;
SELECT 
	*, 
	RANK() OVER (ORDER BY x NULLS FIRST) rank_nulls_first,
	RANK() OVER (ORDER BY x NULLS LAST) rank_nulls_last,
FROM VALUES (1), (1), (1), (NULL) as issue8315(x)
ORDER BY x;
PRAGMA enable_verification;
CREATE TABLE t1(a REAL, b INTEGER);
INSERT INTO t1 VALUES
  (5, 10), (10, 20), (13, 26), (13, 26),
  (15, 30), (20, 40), (22,80), (30, 90);
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a, b RANGE BETWEEN 5 PRECEDING AND 5 FOLLOWING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a RANGE BETWEEN 'a' PRECEDING AND 'a' FOLLOWING );
CREATE VIEW c1 AS SELECT a::tinyint AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::tinyint PRECEDING AND 5::tinyint FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::smallint AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::smallint PRECEDING AND 5::smallint FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::integer AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::integer PRECEDING AND 5::integer FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::bigint AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::bigint PRECEDING AND 5::bigint FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::hugeint AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::hugeint PRECEDING AND 5::hugeint FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::utinyint AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::utinyint PRECEDING AND 5::utinyint FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::usmallint AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::usmallint PRECEDING AND 5::usmallint FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::uinteger AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::uinteger PRECEDING AND 5::uinteger FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::ubigint AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::ubigint PRECEDING AND 5::ubigint FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::uhugeint AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::uhugeint PRECEDING AND 5::uhugeint FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::float AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::float PRECEDING AND 5::float FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::double AS a, b FROM t1;
SELECT a, sum(b) OVER win 
FROM c1 
WINDOW win AS ( ORDER BY a RANGE BETWEEN 5::double PRECEDING AND 5::double FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT INTERVAL (a) DAYS AS a, b FROM t1;
SELECT a, sum(b) OVER win FROM c1
WINDOW win AS ( ORDER BY a
	RANGE BETWEEN interval 5 days PRECEDING AND interval 5 days FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT '2021-07-28'::DATE + INTERVAL (a) DAYS AS a, b FROM t1;
SELECT a, sum(b) OVER win FROM c1
WINDOW win AS ( ORDER BY a
	RANGE BETWEEN interval 5 days PRECEDING AND interval 5 days FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT '2021-07-28'::TIMESTAMP + INTERVAL (a) HOURS AS a, b FROM t1;
SELECT a, sum(b) OVER win FROM c1
WINDOW win AS ( ORDER BY a
	RANGE BETWEEN INTERVAL 5 HOURS PRECEDING AND INTERVAL 5 HOURS FOLLOWING );
DROP VIEW c1;
CREATE TABLE t_time(t TIME);
INSERT INTO t_time VALUES 
	('12:30:00'),
    ('22:30:00'),
    ('13:30:00'),
    ('01:30:00'),
    ('15:30:00'),
    ('20:30:00'),
    ('04:30:00'),
    ('06:30:00'),
    ('18:30:00'),
    ('21:30:00'),
    ('00:30:00'),
    ('00:31:00');
SELECT t, FIRST_VALUE(t) OVER w AS fv 
FROM t_time 
WINDOW w AS (ORDER BY t RANGE INTERVAL 2 HOUR PRECEDING);
CREATE VIEW c1 AS SELECT a::boolean AS a, b FROM t1;
SELECT a, sum(b) OVER win FROM c1 WINDOW win AS ( ORDER BY a RANGE BETWEEN 5 PRECEDING AND 5 FOLLOWING );
DROP VIEW c1;
CREATE VIEW c1 AS SELECT a::varchar AS a, b FROM t1;
SELECT a, sum(b) OVER win FROM c1 WINDOW win AS ( ORDER BY a RANGE BETWEEN 5 PRECEDING AND 5 FOLLOWING );
DROP VIEW c1;
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a RANGE BETWEEN 5 PRECEDING AND 5 FOLLOWING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a RANGE BETWEEN 10 PRECEDING AND 5 PRECEDING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a RANGE BETWEEN 2 FOLLOWING AND 3 FOLLOWING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a DESC RANGE BETWEEN 5 PRECEDING AND 5 FOLLOWING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a DESC RANGE BETWEEN 10 PRECEDING AND 5 PRECEDING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a DESC RANGE BETWEEN 2 FOLLOWING AND 3 FOLLOWING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a RANGE BETWEEN 5.1 PRECEDING AND 5.3 FOLLOWING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a RANGE BETWEEN 10.2 PRECEDING AND 5.4 PRECEDING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a RANGE BETWEEN 2.6 FOLLOWING AND 3.5 FOLLOWING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a DESC RANGE BETWEEN 5.7 PRECEDING AND 5.8 FOLLOWING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a DESC RANGE BETWEEN UNBOUNDED PRECEDING AND 5.9 PRECEDING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a DESC RANGE BETWEEN 2.1 FOLLOWING AND UNBOUNDED FOLLOWING );
SELECT CAST(a AS INTEGER), sum(b) OVER win FROM t1 WINDOW win AS ( ORDER BY a RANGE 5.1 PRECEDING );
DROP TABLE IF EXISTS t1;
CREATE TABLE t1(a INTEGER, b INTEGER);
INSERT INTO t1 VALUES
    (NULL, 1), (NULL, 2), (NULL, 3), (10, 4), (10, 5);
SELECT sum(b) OVER (
    ORDER BY a RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1;
SELECT sum(b) OVER (
    ORDER BY a DESC RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1;
SELECT sum(b) OVER (
    ORDER BY a RANGE BETWEEN 5 FOLLOWING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1 NULLS FIRST;
SELECT sum(b) OVER (
    ORDER BY a RANGE BETWEEN 5 FOLLOWING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1 NULLS LAST;
SELECT sum(b) OVER (
    ORDER BY a DESC RANGE BETWEEN 5 FOLLOWING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1 NULLS FIRST;
SELECT sum(b) OVER (
    ORDER BY a DESC RANGE BETWEEN 5 FOLLOWING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1 NULLS LAST;
SELECT sum(b) OVER (
    ORDER BY a NULLS FIRST RANGE BETWEEN UNBOUNDED PRECEDING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1 NULLS FIRST;
SELECT sum(b) OVER (
    ORDER BY a NULLS LAST RANGE BETWEEN UNBOUNDED PRECEDING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1 NULLS LAST;
SELECT sum(b) OVER (
    ORDER BY a ASC  NULLS LAST RANGE BETWEEN UNBOUNDED PRECEDING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1 NULLS LAST;
SELECT sum(b) OVER (
    ORDER BY a DESC NULLS FIRST RANGE
    BETWEEN UNBOUNDED PRECEDING AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1 NULLS LAST;
SELECT sum(b) OVER (
    ORDER BY a NULLS FIRST RANGE BETWEEN CURRENT ROW AND 10 FOLLOWING
  ) FROM t1 ORDER BY 1 NULLS FIRST;
DROP TABLE IF EXISTS t2;
CREATE TABLE t2(a TEXT, b INTEGER);
INSERT INTO t2 VALUES('A', NULL);
INSERT INTO t2 VALUES('B', NULL);
INSERT INTO t2 VALUES('C', 1);
SELECT group_concat(a, '.') OVER (
    ORDER BY b NULLS FIRST RANGE BETWEEN 7 PRECEDING AND 2 PRECEDING
  )
  FROM t2;
SELECT group_concat(a, '.') OVER (
    ORDER BY b DESC NULLS LAST RANGE BETWEEN 7 PRECEDING AND 2 PRECEDING
  )
  FROM t2;
DROP TABLE IF EXISTS t2;
CREATE TABLE t2(a INTEGER, b INTEGER);
INSERT INTO t2 VALUES(1, 65);
INSERT INTO t2 VALUES(2,	NULL);
INSERT INTO t2 VALUES(3,	NULL);
INSERT INTO t2 VALUES(4,	NULL);
INSERT INTO t2 VALUES(5, 66);
INSERT INTO t2 VALUES(6, 67);
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 6 FOLLOWING AND UNBOUNDED FOLLOWING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 1 PRECEDING AND 2 PRECEDING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 2 FOLLOWING AND 1 FOLLOWING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 1 PRECEDING AND 2 PRECEDING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 2 FOLLOWING AND 1 FOLLOWING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 1000 PRECEDING AND 2 PRECEDING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 2000 FOLLOWING AND 1000 FOLLOWING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 1000 PRECEDING AND 2000 PRECEDING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 2000 FOLLOWING AND 1000 FOLLOWING
  );
SELECT min (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 6 FOLLOWING AND UNBOUNDED FOLLOWING
  );
SELECT min (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 1 PRECEDING AND 2 PRECEDING
  );
SELECT min (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 2 FOLLOWING AND 1 FOLLOWING
  );
SELECT min (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 1 PRECEDING AND 2 PRECEDING
  );
SELECT min (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 2 FOLLOWING AND 1 FOLLOWING
  );
SELECT min (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 1000 PRECEDING AND 2 PRECEDING
  );
SELECT min (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 2000 FOLLOWING AND 1000 FOLLOWING
  );
SELECT min (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 1000 PRECEDING AND 2000 PRECEDING
  );
SELECT min (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 2000 FOLLOWING AND 1000 FOLLOWING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 6 FOLLOWING AND UNBOUNDED FOLLOWING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 1 PRECEDING AND 2 PRECEDING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 2 FOLLOWING AND 1 FOLLOWING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 1 PRECEDING AND 2 PRECEDING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 2 FOLLOWING AND 1 FOLLOWING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 1000 PRECEDING AND 2 PRECEDING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 2000 FOLLOWING AND 1000 FOLLOWING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 1000 PRECEDING AND 2000 PRECEDING
  );
SELECT sum (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 2000 FOLLOWING AND 1000 FOLLOWING
  );
SELECT max (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 6 FOLLOWING AND UNBOUNDED FOLLOWING
  );
SELECT max (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 1 PRECEDING AND 2 PRECEDING
  );
SELECT max (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 2 FOLLOWING AND 1 FOLLOWING
  );
SELECT max (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 1 PRECEDING AND 2 PRECEDING
  );
SELECT max (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 2 FOLLOWING AND 1 FOLLOWING
  );
SELECT max (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 1000 PRECEDING AND 2 PRECEDING
  );
SELECT max (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS LAST RANGE BETWEEN 2000 FOLLOWING AND 1000 FOLLOWING
  );
SELECT max (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 1000 PRECEDING AND 2000 PRECEDING
  );
SELECT max (a) OVER win FROM t2
  WINDOW win AS (
      ORDER BY b NULLS FIRST RANGE BETWEEN 2000 FOLLOWING AND 1000 FOLLOWING
  );
DROP TABLE IF EXISTS tx;
CREATE TABLE tx(a INTEGER PRIMARY KEY);
INSERT INTO tx VALUES(1), (2), (3), (4), (5), (6);
DROP TABLE IF EXISTS map;
CREATE TABLE map(v INTEGER PRIMARY KEY, t TEXT);
INSERT INTO map VALUES
    (1, 'odd'), (2, 'even'), (3, 'odd'),
    (4, 'even'), (5, 'odd'), (6, 'even');
SELECT sum(a) OVER (
    PARTITION BY (
SELECT t FROM map WHERE v=a
    ) ORDER BY a
  ) FROM tx ORDER BY ALL;
SELECT sum(a) OVER win FROM tx
  WINDOW win AS (
    PARTITION BY (
SELECT t FROM map WHERE v=a
    ) ORDER BY a
  ) ORDER BY ALL;
  WITH map2 AS (
SELECT * FROM map
  )
SELECT sum(a) OVER (
    PARTITION BY (
SELECT t FROM map2 WHERE v=a
    ) ORDER BY a
  ) FROM tx ORDER BY ALL;
  WITH map2 AS (
SELECT * FROM map
  )
SELECT sum(a) OVER win FROM tx
  WINDOW win AS (
    PARTITION BY (
SELECT t FROM map2 WHERE v=a
    ) ORDER BY a
  ) ORDER BY ALL;
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t2;
CREATE TABLE t1(a INTEGER);
CREATE TABLE t2(y INTEGER);
SELECT (
SELECT max(a) OVER ( ORDER BY (SELECT sum(a) FROM t1) )
         + min(a) OVER()
  )
  FROM t1;
SELECT b, sum(b) OVER (
    ORDER BY a NULLS LAST RANGE BETWEEN UNBOUNDED PRECEDING AND 10 FOLLOWING
  )
FROM (
	SELECT CASE WHEN b < 70 THEN NULL ELSE 10 END AS a, b
	FROM range(1, 129) tbl(b)
	) t1
ORDER BY 1;
CREATE TABLE rides (
	id INTEGER,
	requested_date DATE,
	city VARCHAR,
	wait_time INTEGER
);
INSERT INTO rides VALUES
	(0, '2023-01-05', 'San Francisco', 2925),
	(1, '2023-01-03', 'San Francisco', 755),
	(2, '2023-01-03', 'San Francisco', 2880),
	(3, '2023-01-05', 'San Francisco', 1502),
	(4, '2023-01-03', 'San Francisco', 2900),
	(5, '2023-01-01', 'San Francisco', 1210),
	(6, '2023-01-04', 'San Francisco', 200),
	(7, '2023-01-02', 'San Francisco', 980),
	(8, '2023-01-02', 'San Francisco', 430),
	(9, '2023-01-05', 'San Francisco', 2999),
	(10, '2023-01-01', 'San Francisco', 856),
	(11, '2023-01-02', 'San Francisco', 490),
	(12, '2023-01-02', 'San Francisco', 720),;
SELECT "id", "requested_date", "city", "wait_time", min("wait_time") OVER win_3d 
FROM rides 
WINDOW win_3d AS (
	PARTITION BY "city" 
	ORDER BY requested_date ASC 
	RANGE BETWEEN INTERVAL 3 DAYS PRECEDING AND INTERVAL 1 DAYS PRECEDING) 
ORDER BY "requested_date", "city", "id";
PRAGMA enable_verification;
create table a as select range%3::tinyint j, range::tinyint AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::smallint j, range::smallint AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::integer j, range::integer AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::bigint j, range::bigint AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::hugeint j, range::hugeint AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::utinyint j, range::utinyint AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::usmallint j, range::usmallint AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::uinteger j, range::uinteger AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::ubigint j, range::ubigint AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::uhugeint j, range::uhugeint AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::float j, range::float AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
create table a as select range%3::double j, range::double AS i from range(1, 7, 1);
select j, i, sum(i) over () from a order by 1,2;
select j, i, sum(i) over (partition by j) from a order by 1,2;
select j, i, sum(i) over (partition by j order by i) from a order by 1,2;
drop table a;
PRAGMA enable_verification;
create table partsupp as select uuid()::varchar as c5 from range(8000);
SELECT (ntile(5002) OVER (ROWS BETWEEN CURRENT ROW AND CURRENT ROW) >= 0), c5 FROM partsupp;
select
   list(row_number) over(rows between unbounded preceding and current row)
from generate_series(5000) t(row_number);
SELECT COUNT(*), SUM(LENGTH(list_aggr)), MIN(LENGTH(list_aggr)), MAX(LENGTH(list_aggr)) FROM (
select
   list(row_number) over(rows between unbounded preceding and current row)
from generate_series(5000) t(row_number)
) t(list_aggr);
PRAGMA enable_verification;
select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i);
with subquery as (select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i)) select * from subquery;
select * from (select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i)) t1;
CREATE VIEW v1 AS select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i);
select * from v1;
SELECT * FROM (SELECT i, lag(i) OVER named_window FROM ( VALUES (1), (2), (3)) AS t (i) window named_window AS ( ORDER BY i)) t1, (SELECT i, lag(i) OVER named_window FROM ( VALUES (1), (2), (3)) AS t (i) window named_window AS ( ORDER BY i)) t2 ORDER BY 1, 2, 3, 4;
WITH subquery AS (SELECT i, lag(i) OVER named_window FROM ( VALUES (1), (2), (3)) AS t (i)) SELECT * FROM subquery window named_window AS ( ORDER BY i);
select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i), named_window as (order by j);
CREATE TABLE a (id INT);
WITH
  cte_a AS (
    SELECT *
    FROM a
    WINDOW my_window AS ()
  ),
  cte_b AS (
    SELECT *
    FROM a
    WINDOW my_window AS ()
  )
SELECT *
FROM cte_a CROSS JOIN cte_b;
PRAGMA enable_verification;
CREATE OR REPLACE TABLE issue10855(i INTEGER, v FLOAT);
INSERT INTO issue10855 VALUES (0, 1), (1, 2), (2, 3),;
SELECT i, v, sum(v) OVER (ORDER BY i RANGE BETWEEN 1 PRECEDING AND -1 FOLLOWING) 
FROM issue10855;
SELECT i, v, sum(v) OVER (ORDER BY i RANGE BETWEEN -1 FOLLOWING AND 1 FOLLOWING) 
FROM issue10855;
SELECT i, v, sum(v) OVER (ORDER BY i RANGE BETWEEN -1 PRECEDING AND 1 FOLLOWING) 
FROM issue10855;
SELECT i, v, sum(v) OVER (ORDER BY i RANGE BETWEEN 1 PRECEDING AND -1 PRECEDING) 
FROM issue10855;
SELECT i, v, sum(v) OVER (ORDER BY i DESC RANGE BETWEEN 1 PRECEDING AND -1 FOLLOWING) 
FROM issue10855;
SELECT i, v, sum(v) OVER (ORDER BY i DESC RANGE BETWEEN -1 FOLLOWING AND 1 FOLLOWING) 
FROM issue10855;
SELECT i, v, sum(v) OVER (ORDER BY i DESC RANGE BETWEEN -1 PRECEDING AND 1 FOLLOWING) 
FROM issue10855;
SELECT i, v, sum(v) OVER (ORDER BY i DESC RANGE BETWEEN 1 PRECEDING AND -1 PRECEDING) 
FROM issue10855;
PRAGMA enable_verification;
SELECT row_number() OVER ();
SELECT avg(42) OVER ();
SELECT concat() OVER ();
SELECT nonexistingfunction() OVER ();
SELECT avg(row_number() over ()) over ();
SELECT avg(42) over (partition by row_number() over ());
SELECT avg(42) over (order by row_number() over ());
PRAGMA enable_verification;
CREATE TABLE empsalary (depname varchar, empno bigint, salary int, enroll_date date);
INSERT INTO empsalary VALUES ('develop', 10, 5200, '2007-08-01'), ('sales', 1, 5000, '2006-10-01'), ('personnel', 5, 3500, '2007-12-10'), ('sales', 4, 4800, '2007-08-08'), ('personnel', 2, 3900, '2006-12-23'), ('develop', 7, 4200, '2008-01-01'), ('develop', 9, 4500, '2008-01-01'), ('sales', 3, 4800, '2007-08-01'), ('develop', 8, 6000, '2006-10-01'), ('develop', 11, 5200, '2007-08-15');
SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname ORDER BY empno) FROM empsalary ORDER BY depname, empno;
SELECT sum(salary) OVER (PARTITION BY depname ORDER BY salary) ss FROM empsalary ORDER BY depname, ss;
SELECT row_number() OVER (PARTITION BY depname ORDER BY salary) rn FROM empsalary ORDER BY depname, rn;
SELECT empno, first_value(empno) OVER (PARTITION BY depname ORDER BY empno) fv FROM empsalary ORDER BY 2 DESC, 1 ASC;
SELECT depname, empno,
	last_value(empno) OVER (
		PARTITION BY depname ORDER BY empno ASC
		ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
		) fv
FROM empsalary
ORDER BY 1, 2;
SELECT depname, salary, dense_rank() OVER (PARTITION BY depname ORDER BY salary) FROM empsalary order by depname, salary;
SELECT depname, salary, rank() OVER (PARTITION BY depname ORDER BY salary) FROM empsalary order by depname, salary;
SELECT depname, min(salary) OVER (PARTITION BY depname ORDER BY salary, empno) m1, max(salary) OVER (PARTITION BY depname ORDER BY salary, empno) m2, AVG(salary) OVER (PARTITION BY depname ORDER BY salary, empno) m3 FROM empsalary ORDER BY depname, empno;
SELECT depname, STDDEV_POP(salary) OVER (PARTITION BY depname ORDER BY salary, empno) s FROM empsalary ORDER BY depname, empno;
SELECT depname, COVAR_POP(salary, empno) OVER (PARTITION BY depname ORDER BY salary, empno) c FROM empsalary ORDER BY depname, empno;
