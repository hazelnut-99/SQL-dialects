PRAGMA enable_verification;
WITH test AS (
	SELECT
		i AS id,
		i AS begin,
		i + 10 AS end,
		i % 2 AS p1,
		i % 3 AS p2
	FROM range(0, 10) tbl(i)
)
SELECT lhs.id, rhs.id
FROM test lhs, test rhs
WHERE lhs.begin < rhs.end
  AND rhs.begin < lhs.end
  AND lhs.p1 <> rhs.p1
  AND lhs.p2 <> rhs.p2
ORDER BY ALL;
WITH test AS (
	SELECT
		i AS id,
		i AS begin,
		i + 10 AS end,
		i % 2 AS p1,
		i % 3 AS p2
	FROM range(0, 10) tbl(i)
)
SELECT lhs.id, rhs.id
FROM test lhs, test rhs
WHERE lhs.begin < rhs.end
  AND rhs.begin < lhs.end
  AND lhs.p1 <> rhs.p1
  AND lhs.p2 <> rhs.p2
ORDER BY ALL;
;
WITH test AS (
	SELECT
		i AS id,
		i AS begin,
		i + 10 AS end,
		i % 2 AS p1,
		i % 3 AS p2
	FROM range(0, 10) tbl(i)
)
SELECT lhs.id, rhs.id
FROM test lhs, test rhs
WHERE lhs.begin < rhs.end
  AND rhs.begin < lhs.end
  AND lhs.p1 <> rhs.p1
  AND lhs.p2 <> rhs.p2
ORDER BY ALL;
WITH test AS (SELECT i AS id, i AS "begin", (i + 10) AS "end", (i % 2) AS p1, (i % 3) AS p2 FROM range(0, 10) AS tbl(i))SELECT lhs.id, rhs.id FROM test AS lhs , test AS rhs WHERE ((lhs."begin" < rhs."end") AND (rhs."begin" < lhs."end") AND (lhs.p1 != rhs.p1) AND (lhs.p2 != rhs.p2)) ORDER BY COLUMNS(*);
;
;
;
;
WITH test AS (
	SELECT
		i AS id,
		i AS begin,
		i + 10 AS end,
		i % 2 AS p1,
		i % 3 AS p2
	FROM range(0, 10) tbl(i)
)
SELECT lhs.id, rhs.id
FROM test lhs, test rhs
WHERE lhs.begin < rhs.end
  AND rhs.begin < lhs.end
  AND lhs.p1 <> rhs.p1
  AND lhs.p2 <> rhs.p2
ORDER BY ALL;
WITH test AS (
	SELECT
		i AS id,
		i AS begin,
		i + 10 AS end,
		i % 2 AS p1,
		i % 3 AS p2
	FROM range(0, 10) tbl(i)
),
sub AS (
	SELECT lhs.id AS lid, rhs.id AS rid
	FROM test lhs, test rhs
	WHERE lhs.begin < rhs.end
	  AND rhs.begin < lhs.end
	  AND lhs.p1 <> rhs.p1
	  AND lhs.p2 <> rhs.p2
	ORDER BY ALL
)
SELECT MIN(lid), MAX(rid)
FROM sub;
WITH test AS (
	SELECT
		i AS id,
		i AS begin,
		i + 10 AS end,
		i % 2 AS p1,
		i % 3 AS p2
	FROM range(0, 10) tbl(i)
),
sub AS (
	SELECT lhs.id AS lid, rhs.id AS rid
	FROM test lhs, test rhs
	WHERE lhs.begin < rhs.end
	  AND rhs.begin < lhs.end
	  AND lhs.p1 <> rhs.p1
	  AND lhs.p2 <> rhs.p2
	ORDER BY ALL
)
SELECT MIN(lid), MAX(rid)
FROM sub;
;
WITH test AS (
	SELECT
		i AS id,
		i AS begin,
		i + 10 AS end,
		i % 2 AS p1,
		i % 3 AS p2
	FROM range(0, 10) tbl(i)
),
sub AS (
	SELECT lhs.id AS lid, rhs.id AS rid
	FROM test lhs, test rhs
	WHERE lhs.begin < rhs.end
	  AND rhs.begin < lhs.end
	  AND lhs.p1 <> rhs.p1
	  AND lhs.p2 <> rhs.p2
	ORDER BY ALL
)
SELECT MIN(lid), MAX(rid)
FROM sub;
WITH test AS (SELECT i AS id, i AS "begin", (i + 10) AS "end", (i % 2) AS p1, (i % 3) AS p2 FROM range(0, 10) AS tbl(i)), sub AS (SELECT lhs.id AS lid, rhs.id AS rid FROM test AS lhs , test AS rhs WHERE ((lhs."begin" < rhs."end") AND (rhs."begin" < lhs."end") AND (lhs.p1 != rhs.p1) AND (lhs.p2 != rhs.p2)) ORDER BY COLUMNS(*))SELECT min(lid), max(rid) FROM sub;
;
;
;
;
WITH test AS (
	SELECT
		i AS id,
		i AS begin,
		i + 10 AS end,
		i % 2 AS p1,
		i % 3 AS p2
	FROM range(0, 10) tbl(i)
),
sub AS (
	SELECT lhs.id AS lid, rhs.id AS rid
	FROM test lhs, test rhs
	WHERE lhs.begin < rhs.end
	  AND rhs.begin < lhs.end
	  AND lhs.p1 <> rhs.p1
	  AND lhs.p2 <> rhs.p2
	ORDER BY ALL
)
SELECT MIN(lid), MAX(rid)
FROM sub;
WITH RECURSIVE t AS
(
	SELECT 1 AS x, 0 AS begin, 4 AS end
UNION ALL
	SELECT lhs.x + 1 AS x,
		GREATEST(lhs.begin, rhs.begin) as begin,
		LEAST(lhs.end, rhs.end) AS end
	FROM t lhs, t rhs
	WHERE lhs.begin + 1 < rhs.end - 1
	  AND rhs.begin + 1 < lhs.end - 1
	  AND lhs.x < 3
)
SELECT COUNT(*) FROM t;
WITH RECURSIVE t AS
(
	SELECT 1 AS x, 0 AS begin, 4 AS end
UNION ALL
	SELECT lhs.x + 1 AS x,
		GREATEST(lhs.begin, rhs.begin) as begin,
		LEAST(lhs.end, rhs.end) AS end
	FROM t lhs, t rhs
	WHERE lhs.begin + 1 < rhs.end - 1
	  AND rhs.begin + 1 < lhs.end - 1
	  AND lhs.x < 3
)
SELECT COUNT(*) FROM t;
;
WITH RECURSIVE t AS
(
	SELECT 1 AS x, 0 AS begin, 4 AS end
UNION ALL
	SELECT lhs.x + 1 AS x,
		GREATEST(lhs.begin, rhs.begin) as begin,
		LEAST(lhs.end, rhs.end) AS end
	FROM t lhs, t rhs
	WHERE lhs.begin + 1 < rhs.end - 1
	  AND rhs.begin + 1 < lhs.end - 1
	  AND lhs.x < 3
)
SELECT COUNT(*) FROM t;
WITH RECURSIVE t AS ((SELECT 1 AS x, 0 AS "begin", 4 AS "end") UNION  ALL (SELECT (lhs.x + 1) AS x, greatest(lhs."begin", rhs."begin") AS "begin", least(lhs."end", rhs."end") AS "end" FROM t AS lhs , t AS rhs WHERE (((lhs."begin" + 1) < (rhs."end" - 1)) AND ((rhs."begin" + 1) < (lhs."end" - 1)) AND (lhs.x < 3))))SELECT count_star() FROM t;
;
;
;
;
WITH RECURSIVE t AS
(
	SELECT 1 AS x, 0 AS begin, 4 AS end
UNION ALL
	SELECT lhs.x + 1 AS x,
		GREATEST(lhs.begin, rhs.begin) as begin,
		LEAST(lhs.end, rhs.end) AS end
	FROM t lhs, t rhs
	WHERE lhs.begin + 1 < rhs.end - 1
	  AND rhs.begin + 1 < lhs.end - 1
	  AND lhs.x < 3
)
SELECT COUNT(*) FROM t;
CREATE TABLE issue3486 AS
SELECT generate_series as ts from generate_series(timestamp '2020-01-01', timestamp '2021-01-01', interval 1 day);;
WITH data_table AS (
    SELECT epoch(ts) as ts
    FROM issue3486
    WHERE ts IS NOT NULL
  ),
  S AS (
    SELECT
      min(ts) as minVal,
      max(ts) as maxVal,
      (max(ts) - min(ts)) as range
      FROM data_table
  ),
  buckets AS (
    SELECT
      range as bucket,
      (range) * (select range FROM S) / 40 + (select minVal from S) as low,
      (range + 1) * (select range FROM S) / 40 + (select minVal from S) as high
    FROM range(0, 40, 1)
  )
  SELECT
      bucket,
      low,
      high,
      count(data_table.ts) as count
    FROM buckets
    LEFT JOIN data_table ON (data_table.ts >= low AND data_table.ts < high)
    GROUP BY bucket, low, high
    ORDER BY bucket;;
WITH data_table AS (
    SELECT epoch(ts) as ts
    FROM issue3486
    WHERE ts IS NOT NULL
  ),
  S AS (
    SELECT
      min(ts) as minVal,
      max(ts) as maxVal,
      (max(ts) - min(ts)) as range
      FROM data_table
  ),
  buckets AS (
    SELECT
      range as bucket,
      (range) * (select range FROM S) / 40 + (select minVal from S) as low,
      (range + 1) * (select range FROM S) / 40 + (select minVal from S) as high
    FROM range(0, 40, 1)
  )
  SELECT
      bucket,
      low,
      high,
      count(data_table.ts) as count
    FROM buckets
    LEFT JOIN data_table ON (data_table.ts >= low AND data_table.ts < high)
    GROUP BY bucket, low, high
    ORDER BY bucket;;
;
WITH data_table AS (
    SELECT epoch(ts) as ts
    FROM issue3486
    WHERE ts IS NOT NULL
  ),
  S AS (
    SELECT
      min(ts) as minVal,
      max(ts) as maxVal,
      (max(ts) - min(ts)) as range
      FROM data_table
  ),
  buckets AS (
    SELECT
      range as bucket,
      (range) * (select range FROM S) / 40 + (select minVal from S) as low,
      (range + 1) * (select range FROM S) / 40 + (select minVal from S) as high
    FROM range(0, 40, 1)
  )
  SELECT
      bucket,
      low,
      high,
      count(data_table.ts) as count
    FROM buckets
    LEFT JOIN data_table ON (data_table.ts >= low AND data_table.ts < high)
    GROUP BY bucket, low, high
    ORDER BY bucket;;
WITH data_table AS (SELECT epoch(ts) AS ts FROM issue3486 WHERE (ts IS NOT NULL)), S AS (SELECT min(ts) AS minVal, max(ts) AS maxVal, (max(ts) - min(ts)) AS "range" FROM data_table), buckets AS (SELECT "range" AS bucket, ((("range" * (SELECT "range" FROM S)) / 40) + (SELECT minVal FROM S)) AS low, (((("range" + 1) * (SELECT "range" FROM S)) / 40) + (SELECT minVal FROM S)) AS high FROM range(0, 40, 1))SELECT bucket, low, high, count(data_table.ts) AS count FROM buckets LEFT JOIN data_table ON (((data_table.ts >= low) AND (data_table.ts < high))) GROUP BY bucket, low, high ORDER BY bucket;
;
;
;
;
WITH data_table AS (
    SELECT epoch(ts) as ts
    FROM issue3486
    WHERE ts IS NOT NULL
  ),
  S AS (
    SELECT
      min(ts) as minVal,
      max(ts) as maxVal,
      (max(ts) - min(ts)) as range
      FROM data_table
  ),
  buckets AS (
    SELECT
      range as bucket,
      (range) * (select range FROM S) / 40 + (select minVal from S) as low,
      (range + 1) * (select range FROM S) / 40 + (select minVal from S) as high
    FROM range(0, 40, 1)
  )
  SELECT
      bucket,
      low,
      high,
      count(data_table.ts) as count
    FROM buckets
    LEFT JOIN data_table ON (data_table.ts >= low AND data_table.ts < high)
    GROUP BY bucket, low, high
    ORDER BY bucket;;
